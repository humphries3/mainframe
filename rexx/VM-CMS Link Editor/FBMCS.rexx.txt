/* ___MCS: Perform MODULE CSECT SPLICE ********************************/        
/*                                                                    */        
/* Maintenance History                                                */        
/*                                                                    */        
/* VER DATE   PGR DESCRIPTION                                         */        
/* --- ----   --- -----------                                         */        
/* 1.0 930713 WAH Initial code.                                       */        
/* 1.1 930716 WAH Continue development.                               */        
/* 1.2 930716 WAH Continue development after mysterious delete.       */        
/* 1.3 930721 WAH Restructure PRTRECON code.                          */        
/* 1.4 930722 WAH Add mult report support.                            */        
/* 1.4 930722 WAH Add mult report support.                            */        
/* 1.5 930727 WAH Add set dimension to ESD dict, misc format chgs.    */        
/* 1.6 930728 WAH Continue 1.5 development.                           */        
/* 1.7 930803 WAH Continue bench check, add EXTREF processing.        */        
/* 1.8 930805 WAH Add HIST function.                                  */        
/* 1.9 930806 WAH Add listing control options, continue cleanup.      */        
/* 2.0 930809 WAH Add NOGEN option.                                   */        
/* 2.1 930810 WAH Continue bench check.                               */        
/* 2.2 930811 WAH Continue bench check, esp. relocate code.           */        
/* 2.3 930812 WAH Continue bench check, esp. relocate code.           */        
/* 2.4 930816 WAH Continue bench check.                               */        
/* 2.5 930817 WAH Continue bench check, misc modifications.           */        
/* 2.6 930818 WAH Continue bench check, misc modifications.           */        
/* 2.7 930820 WAH Fix XA LD determination.                            */        
/* 2.8 930823 WAH Add check for dup names, resolving to T/A names.    */        
/* 2.9 930824 WAH Add MAPGEN option; remove code to identify SD if    */        
/*                INFO fld changes.                                   */        
/* 3.0 931027 WAH Add ESDGEN option; change map parsing code to       */        
/*                reflect successful code in MCR29.                   */        
/* 3.1 931028 WAH Add pass2 type logging to ESD output.               */        
/* 3.2 931029 WAH Refine LD/SD determination again.                   */        
/* 3.3 931101 WAH Enhance VACC to allow R/O (for user disk scans).    */        
/*                Fix msg prefix.                                     */        
/*                Allow genfm to point to input disk (reqd removing   */        
/*                FBSEL code and doing LISTFILE directly).            */        
/* 3.4 931130 WAH Replace INTERPRET code to allow compilation.        */        
/* 3.5        WAH Skipped.                                            */        
/* 3.6        WAH Skipped.                                            */        
/* 3.7 931201 WAH Add full config fileid in parm.                     */        
/* 3.8 931202 WAH Add MODSKIP param; relax RLD flag validation;       */        
/*                make HST RECFM F; remove SD/CM not DW-align err;    */        
/*                add space check and MODSAVE to MODWRT rtn.          */        
/* 3.9 931209 WAH Replace map parse code with FBMOD10.                */        
/* 4.0 931213 WAH Upgrade  to FBMOD11; add QUIET and DSKID options;   */        
/*                combine mult occurrences of msg 120E to keep 1      */        
/*                log entry per module; add binary rep of devno for   */        
/*                sorting to hist file; allow 1 instance of 125E.     */        
/* 4.1 931219 WAH Chg update procedure to backout module from target  */        
/*                disk, ERASE from target disk, and create spliced    */        
/*                copy from backout copy; remove DSKID option.        */        
/* 4.2 931221 WAH Add support for wildcard T/A defs; validate config  */        
/*                keywords.                                           */        
/* 4.3 931221 WAH Continue 4.2.                                       */        
/* 4.4 931223 WAH Add mult RA support.                                */        
/* 4.5 931228 WAH Continue 4.4.                                       */        
/* 4.6 931229 WAH Fix map entry construction in RAGGRND; add ERASE    */        
/*                for backout module copy in NOSAVE & GEN path.       */        
/* 4.7 940801 WAH Add support for disk dictionary.                    */        
/**********************************************************************/        
                                                                                
signal on error                                                                 
signal on novalue                                                               
signal on syntax                                                                
                                                                                
address command                                                                 
numeric digits 10                                                               
                                                                                
parse value time("R") with .                                                    
parse source . .  xfn .                                                         
xuser = userid()                                                                
xdate = date("U")                                                               
xtime = time()                                                                  
xfn8 = left(xfn,8,"_")                                                          
cpfx = substr(xfn8,1,2)                                                         
mpfx = substr(xfn8,1,5)                                                         
xrel  = substr(xfn8,6,1)"."substr(xfn8,7,1)                                     
xrc = 0                                                                         
tcpumin1 = c2d(substr(diag('c'),25,8))/60000000                                 
alfchr = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"                                           
hexchr = "0123456789ABCDEF"                                                     
numchr = "0123456789"                                                           
spcchr = "@#$"                                                                  
fidchr = alfchr||numchr||spcchr||"+-_:"                                         
fidwld = fidchr"*%"                                                             
                                                                                
linkdone.    = 0                                                                
linkdone.0   = 1 /* link normal                   */                            
linkdone.102 = 1 /* link forced r/o - other user  */                            
linkdone.103 = 1 /* link forced r/o - other users */                            
                                                                                
linkfatal.     = 0                                                              
linkfatal.53   = 1 /* USERID not in dir */                                      
linkfatal.107  = 1 /* DEVNUM not in dir */                                      
linkfatal.108  = 1 /* VOLUME not mountd */                                      
linkfatal.1151 = 1 /* MDISK not w/i xtnt*/                                      
                                                                                
                                                                                
fbmodpgm = "FBMOD11"                                                            
call acclist                                                                    
sysnoa = 0                                                                      
sysproc = 0                                                                     
sysatt = 0                                                                      
pagno. = 0                                                                      
secnum. = 0                                                                     
newsec. = 1                                                                     
endrep. = 0                                                                     
lincnt. = 0                                                                     
linmax. = 60                                                                    
linwid  = 132                                                                   
eddskidx. = 0                                                                   
edmodidx. = 0                                                                   
eplogsp = " "                                                                   
epround. = 0                                                                    
hstrc  = 0                                                                      
splrc  = 0                                                                      
cscrc  = 0                                                                      
hs = left("",4)                                                                 
hsc = "."                                                                       
hsp = left("",3)                                                                
resethi4 = "7fffffff"x                                                          
dec20000 = c2d("20000"x)                                                        
nosavft = "-NOSAVE-"                                                            
                                                                                
valopns = "MAPGEN CSECT TRACE NOGEN RECON ERASE HIST SPLICE EXTREF",            
          "ESDGEN ERASE* QUIET NOSAVE"                                          
                                                                                
/* Note that the ESD dictionary filename is the config filename   */            
/* with which this EXEC is called (as passed to FBMOD) and cannot */            
/* be customized.                                                 */            
                                                                                
valcfg = "AGG. AVLKB",                                                          
         "BCKBGN BCKFM BCKFN BCKFT CSCFM CSCFN CSCFT CSPADC",                   
         "DEFOPNS DSKFN DSKFT DSKFM DTLFM DTLFN DTLFT EPWILD",                  
         "ESDFM ESDFT",                                                         
         "HSTFM HSTFN HSTFT LNKMOD LOGFM LOGFN LOGFT",                          
         "MODGEN MODSKIP NULLC PCTMOD PGMFN PGMFT",                             
         "SPLFM SPLFN SPLFT SYS_CMD SYS_IO SYS_SYNTAX",                         
         "TMPDEV TMPFM UHDR."                                                   
                                                                                
statdat = translate('781245',xdate,'12345678')                                  
stattim = translate('124578',xtime,'12345678')                                  
                                                                                
h.0.0 = 4                                                                       
hlin.0 = 5                                                                      
                                                                                
h.0.1 = "1" ||,                                                                 
  center("M O D U L E   C O N T R O L   S E C T I O N   S P L I C E",           
  "  ("xrel")",linwid)                                                          
                                                                                
rcpamerr = 16 /* parameter error                          */                    
rcsyserr = 12 /* operating error                          */                    
rcnoatt  = 8  /* all dsk entries' attempt indr's were off */                    
rcinc    = 4  /* 1 or more dsk entries incomplete at end  */                    
                                                                                
/*********************************************************************/         
/* Parse plist                                                       */         
/*********************************************************************/         
                                                                                
arg cfgfn cfgft argfm extra "(" argopns                                         
                                                                                
if cfgfn = "" then do                                                           
   say mpfx"0001E No configuration file specified"                              
   return rcpamerr                                                              
   end                                                                          
                                                                                
if extra ^= "" then do                                                          
   say mpfx"0010E Superfluous operands:" strip(extra,'b')                       
   return rcpamerr                                                              
   end                                                                          
                                                                                
if cfgft = "" | cfgft = "=" then cfgft = mpfx                                   
if argfm = "" | argfm = "=" then argfm = "*"                                    
                                                                                
if ^vfnt("Configuration filename",cfgfn) then return rcpamerr                   
if ^vfnt("Configuration filetype",cfgft) then return rcpamerr                   
                                                                                
/*********************************************************************/         
/* Initialize CONFIG file variables in case not supplied:            */         
/*********************************************************************/         
                                                                                
v.agg.0 = 0                                                                     
v.avlkb = ""                                                                    
v.bckbgn = 1                                                                    
v.bckfm = "A"                                                                   
v.bckfn = cfgfn                                                                 
v.bckft = "FBMCSB"                                                              
v.cscfm = "A"                                                                   
v.cscfn = cfgfn                                                                 
v.cscft = mpfx"C"                                                               
v.cspadc = "0"                                                                  
v.defopns = ""                                                                  
v.dskfm = "A"                                                                   
v.dskfn = cfgfn                                                                 
v.dskft = mpfx"D"                                                               
v.dtlfm = "A"                                                                   
v.dtlfn = cfgfn                                                                 
v.dtlft = mpfx"2"                                                               
v.epwild = ""                                                                   
v.esdfm = "A"                                                                   
v.esdft = mpfx"E"                                                               
v.hstfm = "A"                                                                   
v.hstfn = cfgfn                                                                 
v.hstft = mpfx"H"                                                               
v.lnkmod = ""                                                                   
v.logfm = "A"                                                                   
v.logfn = cfgfn                                                                 
v.logft = mpfx"1"                                                               
v.modgen = "ALL"                                                                
v.modskip = ""                                                                  
v.nullc = "/"                                                                   
v.pctmod = 100                                                                  
v.pgmfn = "*"                                                                   
v.pgmft = "MODULE"                                                              
v.splfm = "A"                                                                   
v.splfn = cfgfn                                                                 
v.splft = mpfx"S"                                                               
v.sys_cmd = ""                                                                  
v.sys_io = 0                                                                    
v.sys_syntax = "nop"                                                            
v.tmpdev = ""                                                                   
v.tmpfm = ""                                                                    
v.uhdr.0 = 0                                                                    
/*-END-*/                                                                       
                                                                                
/*********************************************************************/         
/*    Check for presence of CONFIG file specified                    */         
/*********************************************************************/         
                                                                                
fndfid = cfgfn cfgft argfm                                                      
q1 = queued()                                                                   
signal off error                                                                
"L" fndfid "(LIFO L"                                                            
signal on  error                                                                
files = queued()-q1                                                             
                                                                                
if files = 0 then do                                                            
   say mpfx"0003E Configuration file '"fndfid"' not found"                      
   return rcpamerr                                                              
   end                                                                          
                                                                                
/*********************************************************************/         
/*    Assign fileid and file spec's from first in search order       */         
/*********************************************************************/         
                                                                                
do files                                                                        
   pull . . cfgfm . cfglr cfgrc . cfgda cfgti .                                 
   end                                                                          
                                                                                
cfgfid = cfgfn cfgft cfgfm                                                      
cfgprtmax = linwid - 4                                                          
                                                                                
if cfglr > cfgprtmax then do                                                    
   say mpfx"0025E Lrecl ("cfglr") of CONFIG ("cfgfid") > max",                  
   "("cfgprtmax")"                                                              
   return rcpamerr                                                              
   end                                                                          
                                                                                
cfgprtlr = max(80,cfglr)                                                        
                                                                                
/*********************************************************************/         
/*    Assign values to configuration keywords...                     */         
/*********************************************************************/         
                                                                                
"EXECIO * DISKR" cfgfid "(FINIS STEM CFGREC."                                   
vspec. = 0                                                                      
ok = 1                                                                          
                                                                                
do i=1 to cfgrec.0                                                              
   parse var cfgrec.i t1 t2                                                     
   if t1 = "" | substr(t1,1,1) = "*" then iterate i                             
   t1 = translate(t1)                                                           
                                                                                
   t1dot = index(t1,".")                                                        
   if t1dot > 0 then t1chk = substr(t1,1,t1dot)                                 
   else t1chk = t1                                                              
                                                                                
   if find(valcfg,t1chk) = 0 then do                                            
      say mpfx"0046E Config KW invalid:" t1                                     
      ok = 0                                                                    
      end                                                                       
                                                                                
   if t1dot > 0 then do                                                         
      parse var t1 t1pref "." t1suff                                            
      if t1suff = "" | verify(t1suff,numchr) > 0 then do                        
         say mpfx"0047E Config KW index invalid:" t1                            
         ok = 0                                                                 
         end                                                                    
      else do                                                                   
         if t1suff = 0 | compare(t1suff,t1suff/1) > 0 then do                   
            say mpfx"0048E Config KW index misspelled:" t1                      
            ok = 0                                                              
            end                                                                 
         else do                                                                
            if find("0 1",t1suff-v.t1pref.0) = 0 then do                        
               say mpfx"0049E Config KW index out of order:" t1                 
               ok = 0                                                           
               end                                                              
            else v.t1pref.0 = t1suff                                            
            end                                                                 
         end                                                                    
      end                                                                       
                                                                                
   t2 = strip(t2,'b')                                                           
                                                                                
   select                                                                       
      when vspec.t1 = 0 then v.t1 = t2                                          
      when t2 = "" then nop                                                     
      otherwise v.t1 = v.t1 t2                                                  
      end                                                                       
   vspec.t1 = vspec.t1 + 1                                                      
   end                                                                          
                                                                                
if ^ok then return rcpamerr                                                     
                                                                                
say mpfx"0004I Running configuration" "'"cfgfn"'"                               
                                                                                
if v.sys_cmd ^= "" then address command v.sys_cmd                               
junk = v.sys_syntax                                                             
                                                                                
actopns = v.defopns argopns                                                     
opnerr = 0                                                                      
                                                                                
do i=1 to words(actopns)                                                        
   if find(valopns,word(actopns,i)) = 0 then do                                 
      say mpfx"0007E Invalid option:" word(actopns,i)                           
      opnerr = 1                                                                
      end                                                                       
   end                                                                          
                                                                                
if opnerr then return rcpamerr                                                  
                                                                                
op_quiet = find(actopns,"QUIET") > 0                                            
op_nosav = find(actopns,"NOSAVE") > 0                                           
op_nogen = find(actopns,"NOGEN") > 0                                            
op_csect = find(actopns,"CSECT") > 0                                            
op_erase = find(actopns,"ERASE") > 0                                            
op_eras2 = find(actopns,"ERASE*") > 0                                           
op_histo = find(actopns,"HIST") > 0                                             
op_recon = find(actopns,"RECON") > 0                                            
op_splic = find(actopns,"SPLICE") > 0                                           
op_trace = find(actopns,"TRACE") > 0                                            
op_extrf = find(actopns,"EXTREF") > 0                                           
op_mapgn = find(actopns,"MAPGEN") > 0                                           
op_esdgn = find(actopns,"ESDGEN") > 0                                           
                                                                                
if ^op_quiet then say mpfx"0002I" mpfx "Release" xrel                           
                                                                                
if ^vnum("AVLKB",v.avlkb,1,9999) then return rcpamerr                           
if ^vnum("BCKBGN",v.bckbgn,1,999999) then return rcpamerr                       
if ^vnum("PCTMOD",v.pctmod,1,100) then return rcpamerr                          
if ^vnum("SYS_IO",v.sys_io,-99999999,99999999) then return rcpamerr             
if ^vwld("PGMFN",v.pgmfn) then return rcpamerr                                  
if ^vwld("PGMFT",v.pgmft) then return rcpamerr                                  
if ^vstr("EPWILD",v.epwild,0,1) then return rcpamerr                            
if ^vstr("NULLC",v.nullc,1,1) then return rcpamerr                              
                                                                                
parse value vhex(v.cspadc,"CSPADC",2,1) with ok .                               
if ^ok then return rcpamerr                                                     
v.cspadc = right(v.cspadc,2,0)                                                  
cspadchr = x2c(v.cspadc)                                                        
avlbyts = v.avlkb * 1024                                                        
pgmkey = strip(v.pgmfn,'b') strip(v.pgmft,'b')                                  
                                                                                
modopn1 = "IE"                                                                  
if op_esdgn then modopn1 = modopn1 || "D"                                       
                                                                                
if ^vfnt("BCKFN",v.bckfn)   then return rcpamerr                                
if ^vfnt("BCKFT",v.bckft)   then return rcpamerr                                
if ^vacc("BCKFM",v.bckfm,1) then return rcpamerr                                
if ^vfnt("CSCFN",v.cscfn)   then return rcpamerr                                
if ^vfnt("CSCFT",v.cscft)   then return rcpamerr                                
if ^vacc("CSCFM",v.cscfm,1) then return rcpamerr                                
if ^vfnt("DSKFN",v.dskfn)   then return rcpamerr                                
if ^vfnt("DSKFT",v.dskft)   then return rcpamerr                                
if ^vacc("DSKFM",v.dskfm,1) then return rcpamerr                                
if ^vfnt("ESDFT",v.esdft)   then return rcpamerr                                
if ^vacc("ESDFM",v.esdfm,1) then return rcpamerr                                
if ^vfnt("LOGFN",v.logfn)   then return rcpamerr                                
if ^vfnt("LOGFT",v.logft)   then return rcpamerr                                
if ^vacc("LOGFM",v.logfm,1) then return rcpamerr                                
if ^vfnt("HSTFN",v.hstfn)   then return rcpamerr                                
if ^vfnt("HSTFT",v.hstft)   then return rcpamerr                                
if ^vacc("HSTFM",v.hstfm,1) then return rcpamerr                                
if ^vfnt("DTLFN",v.dtlfn)   then return rcpamerr                                
if ^vfnt("DTLFT",v.dtlft)   then return rcpamerr                                
if ^vacc("DTLFM",v.dtlfm,1) then return rcpamerr                                
if ^vfnt("SPLFN",v.splfn)   then return rcpamerr                                
if ^vfnt("SPLFT",v.splft)   then return rcpamerr                                
if ^vacc("SPLFM",v.splfm,1) then return rcpamerr                                
                                                                                
/**********************************************************************/        
/* Validate temp filemode (TMPFM)                                     */        
/*                                                                    */        
/* (TMPFM must be validated after all other filemode parameters       */        
/*  are passed to VACC, which keeps track of filemodes used):         */        
/**********************************************************************/        
                                                                                
if ^vtmp(v.tmpfm) then return rcpamerr                                          
                                                                                
/**********************************************************************/        
/* Validate temp device and link mode:                                */        
/**********************************************************************/        
                                                                                
parse value vhex(v.tmpdev,"TMPDEV",4,1) with ok .                               
if ^ok then return rcpamerr                                                     
                                                                                
if ^vlnkmod(v.lnkmod) then return rcpamerr                                      
                                                                                
/**********************************************************************/        
/* Assign fileids:                                                    */        
/**********************************************************************/        
                                                                                
reports = 2                                                                     
                                                                                
repfid.1 = v.dtlfn v.dtlft v.dtlfm                                              
repfid.2 = v.logfn v.logft v.logfm                                              
cscfid =   v.cscfn v.cscft v.cscfm                                              
dskfid =   v.dskfn v.dskft v.dskfm                                              
bckfid =   v.bckfn v.bckft v.bckfm                                              
hstfid =   v.hstfn v.hstft v.hstfm                                              
esdfid =   cfgfn   v.esdft v.esdfm                                              
splfid =   v.splfn v.splft v.splfm                                              
                                                                                
/**********************************************************************/        
/* Do extended validation:                                            */        
/**********************************************************************/        
                                                                                
if ^vdsk() then return rcpamerr                                                 
if ^vgen() then return rcpamerr                                                 
if ^vagg() then return rcpamerr                                                 
                                                                                
/**********************************************************************/        
/* Assign skipped module filenames to stem logical:                   */        
/**********************************************************************/        
                                                                                
modskipnam. = 0                                                                 
do i=1 to words(v.modskip)                                                      
   suff = word(v.modskip,i)                                                     
   modskipnam.suff = 1                                                          
   end                                                                          
                                                                                
/**********************************************************************/        
/* Erase files subject to ERASE* option:                              */        
/**********************************************************************/        
                                                                                
if ^cerase(esdfid,op_eras2)   then return rcpamerr                              
if ^cerase(cscfid,op_eras2)   then return rcpamerr                              
if ^cerase(hstfid,op_eras2)   then return rcpamerr                              
if ^cerase(splfid,op_eras2)   then return rcpamerr                              
if ^cerase(repfid.1,op_eras2) then return rcpamerr                              
if ^cerase(repfid.2,op_eras2) then return rcpamerr                              
                                                                                
/**********************************************************************/        
/* Erase files subject to ERASE  option:                              */        
/**********************************************************************/        
                                                                                
if ^outchk(repfid.1,op_erase) then return rcpamerr                              
if ^outchk(repfid.2,op_erase) then return rcpamerr                              
                                                                                
/**********************************************************************/        
/* Ask for operator confirmation of NOSAVE option:                    */        
/**********************************************************************/        
                                                                                
if op_nosav then do                                                             
   say mpfx"0059I Confirm NOSAVE option (Y|N):"                                 
   pull ans .                                                                   
   if ^abbrev("YES",ans,1) then return rcpamerr                                 
   end                                                                          
                                                                                
else do                                                                         
   if ^vbck() then return rcpamerr                                              
   end                                                                          
                                                                                
wrkfm = v.tmpfm                                                                 
if cmsdisk.wrkfm then call reldisk wrkfm                                        
                                                                                
if substr(diagrc(8,"Q V" v.tmpdev),1,9) = 0 then call detdisk v.tmpdev          
                                                                                
call clsthdrs 2                                                                 
                                                                                
do i=1 to cfgrec.0                                                              
   call prt 2,right(i,3) left(cfgrec.i,cfgprtlr)                                
   end                                                                          
                                                                                
drop cfgrec.                                                                    
call xsumhdrs 2                                                                 
                                                                                
                                                                                
/* Main line ---------------------------------------------------------*/        
                                                                                
do dskidx = 1 to dskrc                                                          
                                                                                
   if ^dskatt.dskidx then do                                                    
      sysnoa = sysnoa + 1                                                       
      iterate dskidx                                                            
      end                                                                       
                                                                                
   sysatt = sysatt + 1                                                          
   lnkrsp= diagrc(8,"LINK" dskusr.dskidx dskdev.dskidx v.tmpdev v.lnkmod)       
                                                                                
   dsklnkmod.dskidx = v.lnkmod                                                  
   dsktodlas.dskidx = substr(date('s'),3) ||,                                   
                      translate('124578',time(),'12345678')                     
   dsklnkrc.dskidx  = substr(lnkrsp,1,9)/1                                      
   lnkrc            = dsklnkrc.dskidx                                           
   dskattseq.dskidx = dskattseq.dskidx + 1                                      
   if dskattseq.dskidx = 1 then dsktodbgn.dskidx = dsktodlas.dskidx             
                                                                                
   select                                                                       
                                                                                
      when linkfatal.lnkrc then do                                              
         call dsklog "0149I Unrecoverable LINK error",                          
         "("right(lnkrc,4,0)")"                                                 
         call chgstat                                                           
         if ^dskupd(dskidx,"FINIS") then signal error                           
         end                                                                    
                                                                                
      when linkdone.lnkrc then do                                               
         signal off error                                                       
         "ACCESS" v.tmpdev v.tmpfm                                              
         signal on error                                                        
                                                                                
         dskaccrc.dskidx = rc                                                   
                                                                                
         if dskaccrc.dskidx ^= 0 then do                                        
            call dsklog "0152I ACCESS error",                                   
            "("right(dskaccrc.dskidx,4,0)")"                                    
            call chgstat                                                        
            if ^dskupd(dskidx,"FINIS") then signal error                        
            end                                                                 
                                                                                
         else do                                                                
                                                                                
            /* check that we have CMS disk - get blksize: */                    
                                                                                
            "Q DISK" v.tmpfm "(LIFO"                                            
            pull qdisk                                                          
            pull                                                                
            modblksz = word(substr(qdisk,8),6)                                  
                                                                                
            /*---------------*/                                                 
            /* non-CMS disk: */                                                 
            /*---------------*/                                                 
                                                                                
            if verify(modblksz,numchr) > 0 then do                              
               call dsklog "0151I Non-CMS DISK ("modblksz")"                    
               call chgstat                                                     
               dskacctyp.dskidx = modblksz                                      
               if ^dskupd(dskidx,"FINIS") then signal error                     
               end                                                              
                                                                                
            /*-----------*/                                                     
            /* CMS disk: */                                                     
            /*-----------*/                                                     
                                                                                
            else do                                                             
               modblkav = substr(qdisk,60,10)/1                                 
               parse value diskproc() with $ok $chg dskacctyp.dskidx            
               if ^$ok then leave dskidx                                        
               if $chg then call chgstat                                        
               if ^dskupd(dskidx,"FINIS") then signal error                     
               end                                                              
                                                                                
            call reldisk(v.tmpdev)                                              
            end                                                                 
                                                                                
         call detdisk(v.tmpdev)                                                 
         end                                                                    
                                                                                
      /*----------------------------------*/                                    
      /* not done or fatal, must be retry */                                    
      /*----------------------------------*/                                    
                                                                                
      otherwise                                                                 
      call dsklog "0150I Recoverable LINK error",                               
      "("right(lnkrc,4,0)")",                                                   
      "(Att"right(dskattseq.dskidx,5,"-")")"                                    
      if ^dskupd(dskidx,"FINIS") then signal error                              
      end                                                                       
   end                                                                          
                                                                                
do i=1 to reports                                                               
   if pagno.i > 0 then do                                                       
      call footer i, "END"                                                      
      "FINIS" repfid.i                                                          
      end                                                                       
   end                                                                          
                                                                                
if hstrc > 0 then "FINIS" hstfid                                                
if cscrc > 0 then "FINIS" cscfid                                                
if splrc > 0 then "FINIS" splfid                                                
                                                                                
parse value time("E") with elapsed "."                                          
tcpumin2 = c2d(substr(diag('c'),25,8))/60000000                                 
                                                                                
if ^op_quiet then say mpfx"0012I ELAP"right(format(elapsed/60,,1),8,"-"),       
"CPU"right(format(tcpumin2-tcpumin1,,2),8,"-") "(MIN)"                          
                                                                                
say mpfx"0058I Disks: NOATT("right(sysnoa,5,0)")",                              
                     "ATT("right(sysatt,5,0)")",                                
                     "PROC("right(sysproc,5,0)")",                              
                     "INC("right(sysatt-sysproc,5,0)")"                         
                                                                                
if sysatt = 0           then call setrc rcnoatt                                 
if (sysatt-sysproc) > 0 then call setrc rcinc                                   
                                                                                
return xrc                                                                      
                                                                                
                                                                                
/* CHGSTAT routine ---------------------------------------------------*/        
                                                                                
chgstat:  procedure expose cpfx mpfx xfn,                                       
          dskatt. dskidx sysproc                                                
                                                                                
dskatt.dskidx = 0                                                               
sysproc = sysproc + 1                                                           
return                                                                          
                                                                                
                                                                                
/* DISKPROC routine --------------------------------------------------*/        
                                                                                
diskproc:                                                                       
                                                                                
signal off error                                                                
"L" v.pgmfn v.pgmft v.tmpfm "(EXEC DATE"                                        
signal on  error                                                                
listrc = rc                                                                     
                                                                                
if listrc = 28 then do                                                          
   call dsklog "0128I No input files"                                           
   return 1 1 "CMS"                                                             
   end                                                                          
                                                                                
if listrc ^= 0 then do                                                          
   call dsklog "0148S LISTFILE error ("right(listrc,4,0)")"                     
   call setrc rcsyserr                                                          
   return 0                                                                     
   end                                                                          
                                                                                
push "file"                                                                     
push "sort * 1 80"                                                              
"XEDIT CMS EXEC A (NOPROF"                                                      
                                                                                
"EXECIO * DISKR CMS EXEC A (FINIS STEM MODLIST."                                
                                                                                
if ^op_quiet then say mpfx"0016I Processing" dskusr.dskidx dskdev.dskidx,       
right(modlist.0,8,".") "file(s)"                                                
                                                                                
pctlast = 0                                                                     
dsksplcnt = 0                                                                   
dskntacnt = 0                                                                   
dsknoqcnt = 0                                                                   
dskskpcnt = 0                                                                   
dskerrcnt = 0                                                                   
                                                                                
                                                                                
do modidx = 1 to modlist.0                                                      
                                                                                
   parse var modlist.modidx . . modfn modft modfm modrf modlr oldmodrc,         
   modbc modda modti .                                                          
                                                                                
   modfid = modfn modft modfm                                                   
   modrdfid = modfid                                                            
   modda = translate('781245',right(modda,8,0),'12345678')                      
   modti = translate('124578',right(modti,8,0),'12345678')                      
   modxa = -1                                                                   
   modrld = -1                                                                  
                                                                                
   pctcmpl = ((modidx-1)*100/modlist.0)%v.pctmod                                
   if pctcmpl > pctlast then do                                                 
      say mpfx"0017I Processing" left(modfn,8) left(modft,8) modfm,             
      "("pctcmpl*v.pctmod"% COMPLETE)"                                          
      pctlast = pctcmpl                                                         
      end                                                                       
                                                                                
   if modskipnam.modfn then do                                                  
      call logsumm "0127A Skipped"                                              
      dskskpcnt = dskskpcnt + 1                                                 
      iterate modidx                                                            
      end                                                                       
                                                                                
   modopenr = 0                                                                 
   modopenw = 0                                                                 
   newsec.1 = 1                                                                 
   raselect. = 0                                                                
   mcselect. = 0                                                                
   mcnamsel. = 0                                                                
   modaggerr = 0                                                                
   modagginc = 0                                                                
   modaggfnd = 0                                                                
   modaggsel = 0                                                                
   modsplice = 0                                                                
                                                                                
   do main=1                           /* use ctl variable for LEAVE  */        
                                                                                
      if ^modparse(1) then do             /* parse MODULE header      */        
         dskerrcnt = dskerrcnt + 1                                              
         leave main                       /* build EP(1) from map     */        
         end                                                                    
                                                                                
      call rlchdrs                                                              
                                                                                
      /*--------------------------------------------------*/                    
      /* Try finding all TA's specified:                  */                    
      /*--------------------------------------------------*/                    
                                                                                
      do aggidx = 1 to v.agg.0                                                  
                                                                                
         /* find TA - assign eplower,   */                                      
         /* upper, width for R/A:       */                                      
                                                                                
         parse value tggloc(aggidx,1,aggidx+1) with $fnd $inc .                 
         modaggfnd = modaggfnd + $fnd                                           
         modagginc = modagginc + $inc                                           
         if ^$fnd then iterate aggidx                                           
                                                                                
         /* look for dup names (names   */                                      
         /* in RA and outside TA in mod)*/                                      
                                                                                
         parse value dupchk(aggidx,1,aggidx+1) with $ok .                       
         if ^$ok then do                                                        
            modaggerr = modaggerr + 1                                           
            iterate aggidx                                                      
            end                                                                 
                                                                                
         /* relocate ESDTXT.aggidx with corr */                                 
         /* RLD - concat for ESDGLOM.aggidx  */                                 
                                                                                
         parse value reloc(aggidx,1,aggidx+1) with $ok .                        
         if ^$ok then do                                                        
            modaggerr = modaggerr + 1                                           
            iterate aggidx                                                      
            end                                                                 
                                                                                
         /* check that RA fits in TA    */                                      
                                                                                
         parse value raggfit(aggidx,aggidx+1) with $ok .                        
         if ^$ok then do                                                        
            modaggerr = modaggerr + 1                                           
            iterate aggidx                                                      
            end                                                                 
                                                                                
         /* if RA < TA, add rounding EP         */                              
         /* to EP(aggidx+1), add pad to ESDGLOM */                              
                                                                                
         call raggrnd aggidx, aggidx+1                                          
         raselect.aggidx = 1                                                    
         modaggsel = modaggsel + 1                                              
         call logsumm "0147I" left(aggnam.aggidx,8) "Selected"                  
         do $cs = mcselect1 to mcselect2                                        
            mcselect.$cs = 1                                                    
            end                                                                 
         end                                                                    
                                                                                
      /*--------------------------------------------------*/                    
      /* If at least 1 TA selected, do splice processing: */                    
      /*--------------------------------------------------*/                    
                                                                                
      if modaggsel > 0 then do                                                  
                                                                                
         /*---------------------------*/                                        
         /* not enough space remains: */                                        
         /*---------------------------*/                                        
                                                                                
         if (modblkav*modblksz) < avlbyts then do                               
            call dsklog "0154I Insufficient space:",                            
            right(modblkav,4) "blk @" right(modblksz,4),                        
            "(Att"right(dskattseq.dskidx,5,"-")")"                              
            return 1 0 "EXPN"                                                   
            end                                                                 
                                                                                
         call splhdrs(1)        /* set splice hdrs for report 1*/               
         newrld = oldrld                                                        
         newmap = oldmap                                                        
                                                                                
         do aggidx = 1 to v.agg.0                                               
            if ^raselect.aggidx then iterate aggidx                             
            call mapsplc aggidx,aggidx+1  /* add/del entries in NEWMAP */       
            call rldsplc aggidx,aggidx+1  /* add/del entries in NEWRLD */       
            end                                                                 
                                                                                
         /* complete information based on new map and rld sizes: */             
                                                                                
         call mapfinis                   /* complete map data          */       
                                                                                
         if ^rldfinis() then do          /* complete rld data          */       
            dskerrcnt = dskerrcnt + 1                                           
            leave main                                                          
            end                                                                 
                                                                                
         parse value modwrt(1) with ok savft .                                  
         if ^ok then do                  /* rewrite mod, splicing text */       
            dskerrcnt = dskerrcnt + 1                                           
            leave main                                                          
            end                                                                 
                                                                                
         if op_recon then call prtrecon  /* print recon report if reqd */       
         modsplice = 1                                                          
         end                                                                    
                                                                                
      /*------------------------------------------------*/                      
      /* Issue message depending on T/A search, splice: */                      
      /*------------------------------------------------*/                      
                                                                                
      select                                                                    
         when modsplice & ^op_nogen then do                                     
            call logsumm "0122A Splice EXC ("savft"), TA:",                     
            aggedit()                                                           
            dsksplcnt = dsksplcnt + 1                                           
            end                                                                 
         when modsplice & op_nogen then do                                      
            call logsumm "0123A Splice SIM ("savft"), TA:",                     
            aggedit()                                                           
            dsksplcnt = dsksplcnt + 1                                           
            end                                                                 
         when modaggfnd > 0 | modagginc > 0 then do                             
            call logsumm "0134A No TA qualify:" aggedit()                       
            dsknoqcnt = dsknoqcnt + 1                                           
            end                                                                 
         otherwise                                                              
         call logsumm "0135A No TA found"                                       
         dskntacnt = dskntacnt + 1                                              
         end                                                                    
                                                                                
      /*------------------------------------------------*/                      
      /* Exit DO labeled with MAIN                      */                      
      /*------------------------------------------------*/                      
                                                                                
      leave main                                                                
      end                                                                       
                                                                                
   if modopenr then "FINIS" modrdfid                                            
   if modopenw then "FINIS" modfid                                              
   end                                                                          
                                                                                
call dsklog "0153I SPL="right(dsksplcnt,5,0),                                   
                  "NOQ="right(dsknoqcnt,5,0),                                   
                  "NTA="right(dskntacnt,5,0),                                   
                  "SKP="right(dskskpcnt,5,0),                                   
                  "ERR="right(dskerrcnt,5,0)                                    
return 1 1 "CMS"                                                                
                                                                                
                                                                                
/**********************************************************************/        
/* AGGEDIT: Edit aggregate processing stats                           */        
/**********************************************************************/        
                                                                                
aggedit:                                                                        
return "Fnd("right(modaggfnd,3,0)") Inc("right(modagginc,3,0)")",               
       "Err("right(modaggerr,3,0)") Sel("right(modaggsel,3,0)")"                
                                                                                
                                                                                
/**********************************************************************/        
/* TGGLOC: FIND T/A in module map                                     */        
/*                                                                    */        
/* (I) $agg   - Index of aggregate being searched for                 */        
/*     $epmod - EP list id for entire module                          */        
/*     $eptgg - EP list id for T/A                                    */        
/*                                                                    */        
/* (O) word1 - 1=T/A found; 0=not found. If found, eplower./epupper.  */        
/*             are assigned for $eptgg, using eplower.$epmod and the  */        
/*             len/disps for the csects located.                      */        
/*     word2 - 1=T/A incomplete or non-qualifying (len err, etc.)     */        
/*             0=T/A complete or completely absent (csect-1 n/f).     */        
/**********************************************************************/        
                                                                                
tggloc:                                                                         
                                                                                
arg $agg, $epmod, $eptgg                                                        
                                                                                
$raggi = 1                                                                      
qselcnt = 0                                                                     
                                                                                
do $taggi = 1 to epcnt.$epmod                                                   
                                                                                
   $selnam = epnam.$epmod.$taggi                                                
   $selagg = mcnamsel.$selnam                                                   
                                                                                
   if abbrev($selnam,tggcsna2.$agg.$raggi) then do                              
                                                                                
      select                                                                    
                                                                                
         when $selagg > 0 then do                                               
            call logsumm "0146E" left(aggnam.$agg,8),                           
            "("right($raggi,2,0)","left(tggcsnam.$agg.$raggi,8)")",             
            "select by ("left(aggnam.$selagg,8)")"                              
            return 0 0                                                          
            end                                                                 
                                                                                
         when eptyp.$epmod.$taggi ^= "SD" then do                               
            call logsumm,                                                       
            "0126E" left(aggnam.$agg,8),                                        
            "("right($raggi,2,0)","left(tggcsnam.$agg.$raggi,8)")",             
            "refers to",                                                        
            "("left(epnam.$epmod.$taggi,8)","eptyp.$epmod.$taggi")"             
            return 0 1                                                          
            end                                                                 
                                                                                
         when epdsp.$epmod.$taggi < 0 |,                                        
         epdsp.$epmod.$taggi >= epwidth.$epmod then do                          
            call logsumm,                                                       
            "0102E" left(aggnam.$agg,8),                                        
            "("right($raggi,2,0)","left(tggcsnam.$agg.$raggi,8)") at",          
            "("left(epnam.$epmod.$taggi,8)","eptyp.$epmod.$taggi")",            
            "outside mod"                                                       
            return 0 1                                                          
            end                                                                 
                                                                                
         when tggcsqua.$agg.$raggi = "*" then do                                
            if tggloc_fnd() then return 1 0                                     
            end                                                                 
                                                                                
         when tggcsqua.$agg.$raggi = "=" then do                                
            call logsumm,                                                       
            "0100E" left(aggnam.$agg,8),                                        
            "("right($raggi,2,0)","left(tggcsnam.$agg.$raggi,8)") at",          
            "("left(epnam.$epmod.$taggi,8)","eptyp.$epmod.$taggi")",            
            "txt mismatch"                                                      
            return 0 1                                                          
            end                                                                 
                                                                                
         otherwise                                                              
         if eplen.$epmod.$taggi < tggcsmin.$agg.$raggi |,                       
            eplen.$epmod.$taggi > tggcsmax.$agg.$raggi then do                  
            call logsumm,                                                       
            "0101E" left(aggnam.$agg,8),                                        
            "("right($raggi,2,0)","left(tggcsnam.$agg.$raggi,8)")",             
            "at ("left(epnam.$epmod.$taggi,8)","eptyp.$epmod.$taggi")",         
            "len ("d2x(eplen.$epmod.$taggi,6)") <> rng",                        
            "("d2x(tggcsmin.$agg.$raggi,6)"-" ||,                               
            d2x(tggcsmax.$agg.$raggi,6)")"                                      
            return 0 1                                                          
            end                                                                 
         else do                                                                
            if tggloc_fnd() then return 1 0                                     
            end                                                                 
         end                                                                    
      end                                                                       
                                                                                
   else if $raggi > 1 & eptyp.$epmod.$taggi ^= "LD" then leave $taggi           
   end                                                                          
                                                                                
if $taggi > epcnt.$epmod then nextlit = "- EOM"                                 
else nextlit = "- next ("left(epnam.$epmod.$taggi,8)"," ||,                     
               eptyp.$epmod.$taggi")"                                           
                                                                                
call logsumm "0144E" left(aggnam.$agg,8),                                       
"("right($raggi,2,0)","left(tggcsnam.$agg.$raggi,8)") not fnd" nextlit          
return 0 0                                                                      
                                                                                
                                                                                
/**********************************************************************/        
/* TGGLOC_FND: Svc routine for TGGLOC - log csect match               */        
/**********************************************************************/        
                                                                                
tggloc_fnd:                                                                     
                                                                                
if $raggi = 1 then do                                                           
   eplower.$eptgg = eplower.$epmod + epdsp.$epmod.$taggi                        
   mcselect1 = $taggi                                                           
   end                                                                          
                                                                                
qselcnt = qselcnt + 1                                                           
qselnam.qselcnt = epnam.$epmod.$taggi                                           
                                                                                
epupper.$eptgg = eplower.$epmod+epdsp.$epmod.$taggi+eplen.$epmod.$taggi         
epwidth.$eptgg = epupper.$eptgg - eplower.$eptgg                                
mcselect2 = $taggi                                                              
$csc.$raggi = $taggi                                                            
                                                                                
if $raggi = tggcscnt.$agg then do                                               
                                                                                
   call logsumm "0145I" left(aggnam.$agg,8) "found",                            
   "- len ("right(epwidth.$eptgg,8)") ("d2x(epwidth.$eptgg,6)")"                
                                                                                
   do $i = 1 to qselcnt                                                         
      $selnam = qselnam.$i                                                      
      mcnamsel.$selnam = $agg                                                   
      end                                                                       
                                                                                
   if op_csect then do $csc=1 to tggcscnt.$agg                                  
      $cscptr = $csc.$csc                                                       
      $cscrec = dskusr.dskidx || dskdev.dskidx ||,                              
                left(modfn,8)   || left(modft,8) || modfm ||,                   
                left(aggnam.$agg,8) ||,                                         
                left(epnam.$epmod.$cscptr,8) ||,                                
                right(eplen.$epmod.$cscptr,8)                                   
      "EXECIO 1 DISKW" cscfid 0 "F" length($cscrec) "(VAR $CSCREC"              
      cscrc = cscrc + 1                                                         
      end                                                                       
   return 1                                                                     
   end                                                                          
                                                                                
else do                                                                         
   $raggi = $raggi + 1                                                          
   return 0                                                                     
   end                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* DUPCHK: Ensure names in R/A don't exist outside T/A in module      */        
/*                                                                    */        
/* (I) $agg  - R/A id                                                 */        
/*     $epmod- EP list id for module                                  */        
/*     $eptgg- EP list id for TA                                      */        
/*                                                                    */        
/* (O) word1 - 1=no dupes found; 0=dupe found.                        */        
/**********************************************************************/        
                                                                                
dupchk:                                                                         
                                                                                
arg $agg, $epmod, $eptgg                                                        
                                                                                
$ok = 1                                                                         
                                                                                
do $i=1 to epcnt.$eptgg                                                         
   do $j=1 to epcnt.$epmod                                                      
      $dupchkloc = eplower.$epmod + epdsp.$epmod.$j                             
      if ($dupchkloc < eplower.$eptgg | $dupchkloc >= epupper.$eptgg) &,        
      epnam.$eptgg.$i = epnam.$epmod.$j & epnam.$eptgg.$i ^= "" then do         
         call logsumm "0125E" left(aggnam.$agg,8),                              
         "("left(epnam.$eptgg.$i,8)","eptyp.$eptgg.$i")",                       
         "outside TA ("d2x($dupchkloc,8)")",                                    
         "as ("eptyp.$epmod.$j")"                                               
         $ok = 0                                                                
         end                                                                    
      end                                                                       
   end                                                                          
                                                                                
do $aggprv = 1 to ($agg-1)                                                      
   if ^raselect.$aggprv then iterate $aggprv                                    
   $epprv = $aggprv + 1                                                         
                                                                                
   do $i=1 to epcnt.$eptgg                                                      
      do $j=1 to epcnt.$epprv                                                   
         if epnam.$eptgg.$i = epnam.$epprv.$j & epnam.$eptgg.$i ^= "",          
         then do                                                                
            call logsumm "0142E" left(aggnam.$agg,8),                           
            "("left(epnam.$eptgg.$i,8)","eptyp.$eptgg.$i")",                    
            "in selected RA as ("eptyp.$epprv.$j")"                             
            $ok = 0                                                             
            end                                                                 
         end                                                                    
      end                                                                       
   end                                                                          
                                                                                
return $ok                                                                      
                                                                                
                                                                                
/**********************************************************************/        
/* MODPARSE: Build module related data structures                     */        
/**********************************************************************/        
                                                                                
modparse:                                                                       
                                                                                
parse arg $ep                                                                   
                                                                                
drop lblsnam. lblsloc. lblstyp. lblsdsc. lblslen. modinfo.                      
                                                                                
fbmodpgm cfgfn modfn modft modfm "?" modopn1 "10000 MODINFO LBLS",              
          dskusr.dskidx dskdev.dskidx v.esdft v.esdfm                           
                                                                                
parse var modinfo.1 . modstat .                                                 
                                                                                
select                                                                          
                                                                                
   when modstat = 0 then nop                                                    
                                                                                
   when modstat = 2 then do                                                     
      call logsumm "0104A Format (F) not supported"                             
      return 0                                                                  
      end                                                                       
                                                                                
   when modstat = 3 then do                                                     
      call logsumm "0109A No map"                                               
      return 0                                                                  
      end                                                                       
                                                                                
   when modstat = 4 then do                                                     
      parse var modinfo.1 . . . . oldhdrl .                                     
      call logsumm "0105A Hdr len unex ("right(oldhdrl,5)")"                    
      return 0                                                                  
      end                                                                       
                                                                                
   when modstat = 5 then do                                                     
      parse var modinfo.1 . . . . . modflg .                                    
      call logsumm "0108A Hdr flg unex:" d2x(modflg,2)                          
      return 0                                                                  
      end                                                                       
                                                                                
   when modstat = 6 then do                                                     
      parse var modinfo.1 . . . . . . . mapentl oldmapec oldmapsz .             
      call logsumm "0113A Map len ("right(oldmapsz,6)")",                       
      "unex ("right(oldmapec*mapentl,6)")"                                      
      return 0                                                                  
      end                                                                       
                                                                                
   when modstat = 7 then do                                                     
      parse var modinfo.1 . . . . . . . . . oldmapsz .                          
      call logsumm "0129A Map len ("right(oldmapsz,6)") too large"              
      return 0                                                                  
      end                                                                       
                                                                                
   when modstat = 8 then do                                                     
      call logsumm "0130A No ESD entries parsed"                                
      return 0                                                                  
      end                                                                       
                                                                                
   when modstat = 9 then do                                                     
      parse var modinfo.1 . . . . . . . . . . . . oldmodrc oldminrc .           
      call logsumm "0131A Rcds fnd" right(oldmodrc,5),                          
      "- req" right(oldminrc,5)                                                 
      return 0                                                                  
      end                                                                       
                                                                                
   when modstat = 10 then do                                                    
      parse var modinfo.1 . . . oldlrecl .                                      
      call logsumm "0132A Lrecl ("right(oldlrecl,6)") > 65535"                  
      return 0                                                                  
      end                                                                       
                                                                                
   when modstat = 11 then do                                                    
      parse var modinfo.1 . . oldstate .                                        
      call logsumm "0133A Open error ("right(oldstate,3)")"                     
      return 0                                                                  
      end                                                                       
                                                                                
   otherwise                                                                    
   say mpfx"0056A Unexpected status ("modstat") from FBMOD"                     
   signal error                                                                 
   end                                                                          
                                                                                
parse var modinfo.1 . . . . oldhdrl modflg modxa mapentl,                       
      oldmapec oldmapsz modfrdec modtodec . . lblcnt .                          
                                                                                
select                                                                          
                                                                                
   when v.modgen = "XA" & ^modxa then do                                        
      call logsumm "0106A 370 module"                                           
      return 0                                                                  
      end                                                                       
                                                                                
   when v.modgen = "370" & modxa then do                                        
      call logsumm "0107A XA module"                                            
      return 0                                                                  
      end                                                                       
                                                                                
   otherwise nop                                                                
   end                                                                          
                                                                                
oldhdr = modinfo.2                                                              
newhdr = oldhdr                                                                 
                                                                                
oldmap = modinfo.3                                                              
maprecl = length(oldmap)                                                        
                                                                                
if modxa then maxrldrc = 2                                                      
else maxrldrc = 1                                                               
                                                                                
/*******************************/                                               
/* determine module length:    */                                               
/*******************************/                                               
                                                                                
modlen = modtodec - modfrdec                                                    
modkbs = ((modlen+1023)%1024)                                                   
                                                                                
/**********************************************************************/        
/* Determine # of module records, based on map entries, module length:*/        
/**********************************************************************/        
                                                                                
oldhdrrc = 1                                                                    
oldtxtrc = (modlen+65534)%65535                                                 
oldmaprc = (oldmapsz+65534)%65535                                               
                                                                                
oldhdrrn = 1                                                                    
oldtxtrn = oldhdrrn + oldhdrrc                                                  
oldmaprn = oldtxtrn + oldtxtrc                                                  
oldrldrn = oldmaprn + oldmaprc                                                  
                                                                                
if modxa then do                                                                
   rldflg = substr(oldhdr,46,1)                                                 
   rldflg80 = bitand(rldflg,"80"x) ^= "0"x                                      
   rldflg40 = bitand(rldflg,"40"x) ^= "0"x                                      
   rldflg20 = bitand(rldflg,"20"x) ^= "0"x                                      
   modrld = rldflg80                                                            
                                                                                
   select                                                                       
      when ^rldflg80 then oldrldrc = 0                                          
      when rldflg80 & rldflg20 then oldrldrc = 2                                
      otherwise  /* rldflg80 & ^rldflg20 */                                     
      if oldrldrn <= oldmodrc then do                                           
         if ^modget(oldrldrn,"RLD",modrdfid) then return 0                      
         rldfirst = substr($modrec,1,1)                                         
         if bitand(rldfirst,"40"x) = "0"x then oldrldrc = 1                     
         else oldrldrc = 0                                                      
         end                                                                    
      else oldrldrc = 0                                                         
      end                                                                       
                                                                                
   modminrc = oldhdrrc + oldtxtrc + oldmaprc + oldrldrc                         
                                                                                
   if oldmodrc < modminrc then do                                               
      call logsumm,                                                             
      "0110A Mod rcd cnt ("right(oldmodrc,5)")",                                
      "- expect ("right(modminrc,5)")"                                          
      return 0                                                                  
      end                                                                       
                                                                                
   if oldrldrc > 0 & rldflg40 then do                                           
      call logsumm "0111A 31-bit RLD not supported"                             
      return 0                                                                  
      end                                                                       
                                                                                
   oldhstrc = oldmodrc - modminrc                                               
   rldentl = 4                                                                  
   end                                                                          
                                                                                
else do                                                                         
   modminrc = oldhdrrc + oldtxtrc + oldmaprc                                    
   if oldmodrc < modminrc | oldmodrc > (modminrc+1) then do                     
      call logsumm,                                                             
      "0112A Module rcd cnt ("right(oldmodrc,5)") - expect",                    
      "("modminrc"-"modminrc+1")"                                               
      return 0                                                                  
      end                                                                       
   else do                                                                      
      oldrldrc = oldmodrc - modminrc                                            
      modrld = oldrldrc > 0                                                     
      oldhstrc = 0                                                              
      rldentl = 4                                                               
      end                                                                       
   end                                                                          
                                                                                
oldhstrn = oldrldrn + oldrldrc                                                  
                                                                                
                                                                                
/**********************************************************************/        
/* Read all RLD records into RLDREC:                                  */        
/**********************************************************************/        
                                                                                
oldrld = ""                                                                     
                                                                                
do j=1 to oldrldrc                                                              
   if ^modget(j+oldrldrn-1,"RLD",modrdfid) then return 0                        
   oldrld = oldrld||$modrec                                                     
   end                                                                          
                                                                                
oldrldl = length(oldrld)                                                        
                                                                                
if oldrldl//rldentl ^= 0 then do                                                
   call logsumm "0114A RLD size ("right(oldrldl,6)")",                          
               "not mult of ("rldentl")"                                        
   return 0                                                                     
   end                                                                          
                                                                                
oldrldec = oldrldl/rldentl                                                      
                                                                                
do $i=1 to oldrldec                                                             
   $off = ($i-1)*rldentl                                                        
   $rldflag = substr(oldrld,$off+1,1)                                           
   $rldalen = c2d(bitand($rldflag,"f"x)) + 1                                    
   $rldaddr = c2d(substr(oldrld,$off+2,3))                                      
   if $rldalen < 3 | $rldalen > 4 then do                                       
      call logsumm "0115A RLD ("right($i,4)") flg invalid:" c2x($rldflag)       
      return 0                                                                  
      end                                                                       
   if $rldaddr < modfrdec |,                                                    
      $rldaddr > (modtodec-$rldalen) then do                                    
      call logsumm "0116A RLD ("right($i,4)")",                                 
      "addr err ("d2x($rldaddr,6)")"                                            
      return 0                                                                  
      end                                                                       
   end                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* Go through map entries adding EP's to EP list:                     */        
/**********************************************************************/        
                                                                                
lblsd = 0                                                                       
epcno.$ep = 0                                                                   
epcnt.$ep = 0                                                                   
                                                                                
do lblidx=1 to lblcnt                                                           
                                                                                
   lblsdsc.lblidx = word("CM LD SD",lblstyp.lblidx+1)                           
                                                                                
   if lblsdsc.lblidx ^= "LD" then do                                            
      lblsd = epgen($ep,lblsnam.lblidx,lblsloc.lblidx-modfrdec,,                
      lblsdsc.lblidx,lblslen.lblidx)                                            
      end                                                                       
                                                                                
   else do                                                                      
      if lblsd = 0 then do                                                      
         call logsumm "0117A LD ("left(lblsnam.lblidx,8)")",                    
         "has no csect"                                                         
         return 0                                                               
         end                                                                    
      call epgen $ep,lblsnam.lblidx,lblsloc.lblidx-modfrdec,,                   
      lblsdsc.lblidx,lblsd                                                      
      end                                                                       
   end                                                                          
                                                                                
eplower.$ep = modfrdec                                                          
epupper.$ep = modtodec                                                          
epwidth.$ep = epupper.$ep - eplower.$ep                                         
                                                                                
return 1                                                                        
                                                                                
                                                                                
/**********************************************************************/        
/* MAPSPLC: Build new map with spliced entries                        */        
/**********************************************************************/        
                                                                                
mapsplc:                                                                        
                                                                                
arg $agg, $eptgg                                                                
                                                                                
newoff = 0                                                                      
                                                                                
do while newoff < length(newmap)                                                
   mapepa = c2d(substr(newmap,newoff+13,4))                                     
   if mapepa >= eplower.$eptgg & mapepa < epupper.$eptgg then do                
      if op_splic then call prt 1, left(aggnam.$agg,8),                         
                  edmspl(-1,substr(newmap,newoff+1,mapentl)),                   
                  edrspl(0) edtspl(0)                                           
      newmap = delstr(newmap,newoff+1,mapentl)                                  
      end                                                                       
   else newoff = newoff + mapentl                                               
   end                                                                          
                                                                                
neweps = ""                                                                     
                                                                                
do epidx = 1 to epcnt.$eptgg                                                    
                                                                                
   $epa = eplower.$eptgg + epdsp.$eptgg.epidx                                   
                                                                                
   if mapentl = 24 then do                                                      
                                                                                
      if eptyp.$eptgg.epidx = "LD" then neweps = neweps ||,                     
           epnam.$eptgg.epidx ||,                                               
           right(d2c($epa),8,"0"x) ||,                                          
           "10"x || right(d2c(eplower.$eptgg),7,"0"x)                           
                                                                                
      else neweps = neweps ||,                                                  
           epnam.$eptgg.epidx ||,                                               
           right(d2c($epa),8,"0"x) ||,                                          
           "12"x || right(d2c(eplower.$eptgg),7,"0"x)                           
      end                                                                       
                                                                                
   else do                                                                      
                                                                                
      if eptyp.$eptgg.epidx = "LD" then neweps = neweps ||,                     
           epnam.$eptgg.epidx ||,                                               
           right(d2c($epa),8,"0"x) ||,                                          
           right("",4,"0"x)                                                     
                                                                                
      else neweps = neweps ||,                                                  
           epnam.$eptgg.epidx ||,                                               
           right(d2c(eplower.$eptgg),4,"0"x) ||,                                
           right(d2c($epa),4,"0"x) ||,                                          
           left("2"x,4,"0"x)                                                    
      end                                                                       
   end                                                                          
                                                                                
if op_splic then do i=1 to length(neweps)/mapentl                               
   call prt 1, left(aggnam.$agg,8),                                             
               edmspl(+1,substr(neweps,(i-1)*mapentl+1,mapentl)),               
               edrspl(0) edtspl(0)                                              
   end                                                                          
                                                                                
newmap = neweps || newmap                                                       
return                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* MAPFINIS: Complete new map data                                    */        
/**********************************************************************/        
                                                                                
mapfinis:                                                                       
newmapec = length(newmap)/mapentl                                               
newmaprc = (length(newmap)+65534)%65535                                         
newhdr = overlay(d2c(newmapec,2),newhdr,41)                                     
return                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* RLDFINIS: Complete new rld data                                    */        
/**********************************************************************/        
                                                                                
rldfinis:                                                                       
                                                                                
newrldec = length(newrld)/rldentl                                               
newrldrc = (length(newrld)+65534)%65535                                         
                                                                                
if newrldrc > maxrldrc then do                                                  
   call logsumm "0118A New RLD rcd cnt ("newrldrc")",                           
   "> max ("maxrldrc")"                                                         
   return 0                                                                     
   end                                                                          
                                                                                
if modxa & modrld then do                                                       
   if newrldrc = 2,                                                             
   then newhdr = overlay(bitor(rldflg,"20"x),newhdr,46)                         
   else newhdr = overlay(bitand(rldflg,"df"x),newhdr,46)                        
   end                                                                          
                                                                                
return 1                                                                        
                                                                                
                                                                                
/**********************************************************************/        
/* RLDSPLC: Build new RLD with spliced entries                        */        
/*                                                                    */        
/* This routine is executed whether or not a module was gen'd with    */        
/* RLDSAVE, primarily to set "newrld" variables to null or 0.         */        
/**********************************************************************/        
                                                                                
rldsplc:                                                                        
                                                                                
arg $agg, $eptgg                                                                
                                                                                
newoff = 0                                                                      
                                                                                
do while newoff < length(newrld)                                                
   rldloc = c2d(substr(newrld,newoff+2,3))                                      
   if rldloc >= eplower.$eptgg & rldloc < epupper.$eptgg then do                
      if op_splic then call prt 1, left(aggnam.$agg,8) edmspl(0),               
      edrspl(-1,substr(newrld,newoff+1,rldentl)) edtspl(0)                      
      newrld = delstr(newrld,newoff+1,rldentl)                                  
      end                                                                       
   else newoff = newoff + rldentl                                               
   end                                                                          
                                                                                
if op_splic then do i=1 to length(rldnew.$agg)/rldentl                          
   $item = substr(rldnew.$agg,(i-1)*rldentl+1,rldentl)                          
   call prt 1, left(aggnam.$agg,8),                                             
               edmspl(0),                                                       
               edrspl(+1,$item),                                                
               edtspl(0)                                                        
   end                                                                          
                                                                                
newrld = rldnew.$agg || newrld                                                  
return                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* PRTRECON: Print EP Reconciliation Journal                          */        
/**********************************************************************/        
                                                                                
prtrecon:                                                                       
                                                                                
h.1.1 = "0" ||,                                                                 
      center("--- ENTRY POINT RECONCILIATION ---",linwid)                       
                                                                                
parse value modhdrs(1,2,2) with $hdrsadd $linsadd                               
                                                                                
$i = $hdrsadd + 2                                                               
                                                                                
h.1.$i = "0" ||,                                                                
      center(,                                                                  
      left("",8),                                                               
      eplogsp,                                                                  
      center(" TARGET MODULE ",40,"-"),                                         
      eplogsp,                                                                  
      center(" REPLACEMENT AGGREGATE ",40,"-"),,                                
      linwid)                                                                   
                                                                                
$i = $i + 1                                                                     
                                                                                
h.1.$i = " " ||,                                                                
      center(,                                                                  
      center("MODULE",8),                                                       
      eplogsp,                                                                  
      center("ENTITY",24,"-") ||,                                               
      left("",1) ||,                                                            
      center("AUX ENTRY",15,"-"),                                               
      eplogsp,                                                                  
      center("ENTITY",24,"-") ||,                                               
      left("",1) ||,                                                            
      center("AUX ENTRY",15,"-"),,                                              
      linwid)                                                                   
                                                                                
$i = $i + 1                                                                     
                                                                                
h.1.$i = " " ||,                                                                
      center(,                                                                  
      center("LOCATION",8),                                                     
      eplogsp,                                                                  
      center("SEQNO ID   NAME   LENGTH",24) ||,                                 
      left("",1) ||,                                                            
      center("  NAME   OFFSET",15),                                             
      eplogsp,                                                                  
      center("SEQNO ID   NAME   LENGTH",24) ||,                                 
      left("",1) ||,                                                            
      center("  NAME   OFFSET",15),,                                            
      linwid)                                                                   
                                                                                
$i = $i + 1                                                                     
                                                                                
h.1.$i = " " ||,                                                                
      center(,                                                                  
      center("--------",8),                                                     
      eplogsp,                                                                  
      center("----- -- -------- ------",24) ||,                                 
      left("",1) ||,                                                            
      center("-------- ------",15),                                             
      eplogsp,                                                                  
      center("----- -- -------- ------",24) ||,                                 
      left("",1) ||,                                                            
      center("-------- ------",15),,                                            
      linwid)                                                                   
                                                                                
h.1.0 =  $hdrsadd + 5                                                           
hlin.1 = $linsadd + 7                                                           
endrep.1 = 1                                                                    
lastoff = ""                                                                    
                                                                                
p. = 0                                                                          
parse value prtpoint(1)   with prtavail1 .                                      
parse value prtpointra(0) with prtavail2 $eptgg .                               
edcsprt. = 0                                                                    
                                                                                
do while prtavail1 | prtavail2                                                  
                                                                                
   select                                                                       
                                                                                
      when prtavail1 & prtavail2 then select                                    
                                                                                
         when epaddr.1 < epaddr.$eptgg then do                                  
            call prt 1, edof(1,epaddr.1),                                       
                     eplogsp,                                                   
                     editcs(1,1,p.1),                                           
                     editep(1,p.1),                                             
                     eplogsp,                                                   
                     omitcs(epselect(1,p.1)),                                   
                     omitep(epselect(1,p.1))                                    
            parse value prtpoint(1) with prtavail1 .                            
            end                                                                 
                                                                                
         when epaddr.1 = epaddr.$eptgg then do                                  
            call prt 1, edof(1,epaddr.1),                                       
                     eplogsp,                                                   
                     editcs(1,1,p.1),                                           
                     editep(1,p.1),                                             
                     eplogsp,                                                   
                     editcs(1,$eptgg,p.$eptgg),                                 
                     editep($eptgg,p.$eptgg)                                    
            parse value prtpoint(1)     with prtavail1 .                        
            parse value prtpointra($eptgg) with prtavail2 $eptgg .              
            end                                                                 
                                                                                
         otherwise do                                                           
            call prt 1, edof(1,epaddr.$eptgg),                                  
                     eplogsp,                                                   
                     omitcs(1),                                                 
                     omitep(1),                                                 
                     eplogsp,                                                   
                     editcs(1,$eptgg,p.$eptgg),                                 
                     editep($eptgg,p.$eptgg)                                    
            parse value prtpointra($eptgg) with prtavail2 $eptgg .              
            end                                                                 
         end                                                                    
                                                                                
      when prtavail1 then do                                                    
         call prt 1, edof(1,epaddr.1),                                          
                  eplogsp,                                                      
                  editcs(1,1,p.1),                                              
                  editep(1,p.1),                                                
                  eplogsp,                                                      
                  omitcs(epselect(1,p.1)),                                      
                  omitep(epselect(1,p.1))                                       
         parse value prtpoint(1) with prtavail1 .                               
         end                                                                    
                                                                                
      when prtavail2 then do                                                    
         call prt 1, edof(1,epaddr.$eptgg),                                     
                  eplogsp,                                                      
                  omitcs(1),                                                    
                  omitep(1),                                                    
                  eplogsp,                                                      
                  editcs(1,$eptgg,p.$eptgg),                                    
                  editep($eptgg,p.$eptgg)                                       
         parse value prtpointra($eptgg) with prtavail2 $eptgg .                 
         end                                                                    
                                                                                
      otherwise signal error                                                    
      end                                                                       
   end                                                                          
                                                                                
return                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* PRTPOINTRA: Increment TA ep list ptr and select next for print    */         
/*********************************************************************/         
                                                                                
prtpointra: procedure expose cpfx mpfx xfn,                                     
            epcnt. p. epaddr. epdsp. eplower. v.agg.0 prtepavl.,                
            raselect.                                                           
                                                                                
arg $ep                                                                         
                                                                                
if $ep = 0 then do                                                              
   do $ra=1 to v.agg.0                                                          
      if ^raselect.$ra then iterate $ra                                         
      $nxtep = $ra + 1                                                          
      prtepavl.$nxtep = prtpoint($nxtep)                                        
      end                                                                       
   end                                                                          
else prtepavl.$ep = prtpoint($ep)                                               
                                                                                
$seltgg = 0                                                                     
                                                                                
do $ra=1 to v.agg.0                                                             
   if ^raselect.$ra then iterate $ra                                            
   $eptgg = $ra + 1                                                             
   if ^prtepavl.$eptgg then iterate $ra                                         
   if $seltgg = 0 then $seltgg = $eptgg                                         
   else if epaddr.$seltgg > epaddr.$eptgg then $seltgg = $eptgg                 
   end                                                                          
                                                                                
return ($seltgg > 0) $seltgg                                                    
                                                                                
                                                                                
/*********************************************************************/         
/* PRTPOINT: Increment ptr and set EPADDR. for EP list specified     */         
/*********************************************************************/         
                                                                                
prtpoint:   procedure expose cpfx mpfx xfn,                                     
            epaddr. epcnt. p. epdsp. eplower.                                   
                                                                                
arg $agg                                                                        
                                                                                
if p.$agg = epcnt.$agg then return 0                                            
p.$agg = p.$agg + 1                                                             
$idx = p.$agg                                                                   
epaddr.$agg = epdsp.$agg.$idx + eplower.$agg                                    
return 1                                                                        
                                                                                
                                                                                
/*********************************************************************/         
/* EDOF: Edit module offset field                                    */         
/*********************************************************************/         
                                                                                
edof:                                                                           
                                                                                
arg $repid, $off                                                                
                                                                                
if lastoff ^= $off | lincnt.$repid >= linmax.$repid then do                     
   if lastoff = $off then $cont = "+"                                           
   else $cont = ""                                                              
   lastoff = $off                                                               
   return right($cont||d2x($off),8)                                             
   end                                                                          
else return left("",8)                                                          
                                                                                
                                                                                
                                                                                
/*********************************************************************/         
/* EDCS: Edit csect info                                             */         
/*********************************************************************/         
                                                                                
editcs:                                                                         
                                                                                
arg $repid, $agg, $idx                                                          
                                                                                
$csptr = $idx                                                                   
if eptyp.$agg.$idx = "LD" then $csptr = epref.$agg.$idx                         
$newcs = (edcsprt.$agg < $csptr)                                                
if $newcs | lincnt.$repid >= linmax.$repid then do                              
   if $newcs then $cont = ""                                                    
   else $cont = "+"                                                             
   $cseq = right($cont||epcno.$agg.$csptr,5)                                    
   $cnam = left(epnam.$agg.$csptr,8)                                            
   $clen = right(d2x(eplen.$agg.$csptr),6)                                      
   edcsprt.$agg = $csptr                                                        
   return $cseq eptyp.$agg.$csptr $cnam $clen                                   
   end                                                                          
else return left("",24)                                                         
                                                                                
omitcs:                                                                         
arg $corrdata                                                                   
if $corrdata then return left("",24)                                            
else return copies(v.nullc,5) copies(v.nullc,2) copies(v.nullc,8),              
copies(v.nullc,6)                                                               
                                                                                
                                                                                
/*********************************************************************/         
/* EPSELECT: Pass by lgl indicating whether current mod EP selected  */         
/*           for replacement                                         */         
/*********************************************************************/         
                                                                                
epselect:                                                                       
                                                                                
arg $epmod, $epidx                                                              
if eptyp.$epmod.$epidx = "LD" then $csidx = epref.$epmod.$epidx                 
else $csidx = $epidx                                                            
return mcselect.$csidx                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* EDEP: Edit entry point info                                       */         
/*********************************************************************/         
                                                                                
editep:                                                                         
                                                                                
arg $agg, $idx                                                                  
                                                                                
if eptyp.$agg.$idx ^= "LD" then return left("",15)                              
$epnam = left(epnam.$agg.$idx,8)                                                
$ref   = epref.$agg.$idx                                                        
$epdsp = right(d2x(epdsp.$agg.$idx-epdsp.$agg.$ref),6)                          
return $epnam $epdsp                                                            
                                                                                
                                                                                
omitep:                                                                         
arg $corrdata                                                                   
if $corrdata then return left("",15)                                            
else return copies(v.nullc,8) copies(v.nullc,6)                                 
                                                                                
                                                                                
/**********************************************************************/        
/* SPLHDRS: Set up Splice listing headings                            */        
/**********************************************************************/        
                                                                                
splhdrs:                                                                        
                                                                                
arg $repid                                                                      
                                                                                
h.$repid.1 = "0" ||,                                                            
      center("--- SPLICE ACTIVITY ---",linwid)                                  
                                                                                
parse value modhdrs($repid,2,2) with $hdrsadd $linsadd                          
                                                                                
$i = $hdrsadd + 2                                                               
                                                                                
h.$repid.$i = "0" ||,                                                           
      center(,                                                                  
      center("",8),                                                             
      center("",45),                                                            
      center("",12),                                                            
      center("TXT SPLICE",23,"-"),,                                             
      linwid)                                                                   
                                                                                
$i = $i + 1                                                                     
                                                                                
h.$repid.$i = " " ||,                                                           
      center(,                                                                  
      center("AGGR",8),                                                         
      center("MAP SPLICE",45),                                                  
      center("RLD SPLICE",12),                                                  
      center("  ADDR   RSEQ ROFF  LEN",23),,                                    
      linwid)                                                                   
                                                                                
$i = $i + 1                                                                     
                                                                                
h.$repid.$i = " " ||,                                                           
      center(,                                                                  
      center("",8,"-"),                                                         
      center("",45,"-"),                                                        
      center("",12,"-"),                                                        
      center("-------- ---- ----  ---",23),,                                    
      linwid)                                                                   
                                                                                
h.$repid.0 = $hdrsadd + 4                                                       
hlin.$repid = $linsadd + 6                                                      
endrep.$repid = 1                                                               
return                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* RAGGFIT: Check that R/A fits in T/A                               */         
/*********************************************************************/         
                                                                                
raggfit:                                                                        
                                                                                
arg $tx, $ep                                                                    
                                                                                
if epwidth.$ep < esdcumln.$tx then do                                           
   call logsumm,                                                                
   "0119E" left(aggnam.$tx,8) "RA len ("d2x(esdcumln.$tx,6)") > TA len",        
   "("d2x(epwidth.$ep,6)")"                                                     
   return 0                                                                     
   end                                                                          
                                                                                
else return 1                                                                   
                                                                                
                                                                                
/*********************************************************************/         
/* RAGGRND: Add dummy csect to round RA up to TA length              */         
/*********************************************************************/         
                                                                                
raggrnd:  procedure expose cpfx mpfx xfn,                                       
         epwidth. epround. epcnt. epnam. epdsp. eptyp. eplen.,                  
         epcno. esdglom. esdcumln. rggpad. cspadchr                             
                                                                                
arg $tx, $ep                                                                    
                                                                                
$esdrndln = epwidth.$ep-esdcumln.$tx                                            
                                                                                
if epround.$ep then do                                                          
   epcnt.$ep = epcnt.$ep - 1                                                    
   epround.$ep = 0                                                              
   end                                                                          
                                                                                
if $esdrndln > 0 then do                                                        
   call epgen $ep,left(rggpad.$tx,8),esdcumln.$tx,"SD",$esdrndln                
   esdglom.$tx = esdglom.$tx || copies(cspadchr,$esdrndln)                      
   epround.$ep = 1                                                              
   end                                                                          
                                                                                
return                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* VMODARCH: Validate MODARCH parameter                              */         
/*********************************************************************/         
                                                                                
vgen:                                                                           
                                                                                
if find("XA 370 ALL",v.modgen) = 0 then do                                      
   if v.modgen = "" then $msgseg = ""                                           
   else $msgseg = "("v.modgen")"                                                
   say mpfx"0005E Module architecture filter invalid" $msgseg                   
   return 0                                                                     
   end                                                                          
return 1                                                                        
                                                                                
                                                                                
/*********************************************************************/         
/* VAGG: Validate aggregate definitions                              */         
/*                                                                   */         
/* (I) AGG. Config data                                              */         
/* (O) Word1: 0---error; 1---ok                                      */         
/*********************************************************************/         
                                                                                
vagg:                                                                           
                                                                                
do i = 1 to v.agg.0                                                             
                                                                                
   parse var v.agg.i aggnam.i ";" tggdef.i ";" rggfid.i ";" rggpad.i ";"        
                                                                                
   /* validate aggregate name: */                                               
                                                                                
   aggnam.i = space(aggnam.i)                                                   
   if length(aggnam.i) = 0 | length(aggnam.i) > 8 |,                            
   words(aggnam.i) > 1 then do                                                  
      say mpfx"0136E Aggregate ("i") name missing or invalid"                   
      return 0                                                                  
      end                                                                       
                                                                                
   if i > 1 then do j=1 to (i-1)                                                
      if aggnam.j = aggnam.i then do                                            
         say mpfx"0137E Aggregate ("i") name same as ("j")"                     
         return 0                                                               
         end                                                                    
      end                                                                       
                                                                                
   /* validate-build target aggregate definitions: */                           
                                                                                
   if ^vtgg(i,tggdef.i) then return 0                                           
                                                                                
   /* validate replacement aggregate */                                         
                                                                                
   parse value fndfil("Aggregate ("i") R/A text",rggfid.i) with,                
         ok fn ft fm .                                                          
   if ^ok then return 0                                                         
   rggfid.i = space(fn ft fm)                                                   
                                                                                
   /* Build ESD_ and RLD_ tables from RA text deck */                           
   /* Build corresponding EP's in EP table (I+1)   */                           
                                                                                
   if ^txtload(i,i+1,rggfid.i) then return 0                                    
                                                                                
   /* validate R/A pad name: */                                                 
                                                                                
   rggpad.i = space(rggpad.i)                                                   
   if length(rggpad.i) = 0 | length(rggpad.i) > 8 |,                            
   words(rggpad.i) > 1 then do                                                  
      say mpfx"0138E Aggregate ("i") R/A pad name missing or invalid"           
      return 0                                                                  
      end                                                                       
                                                                                
   if i > 1 then do j=1 to (i-1)                                                
      if rggpad.j = rggpad.i then do                                            
         say mpfx"0139E Aggregate ("i") R/A pad name same as ("j")"             
         return 0                                                               
         end                                                                    
      end                                                                       
   end                                                                          
                                                                                
if ^op_quiet then do i=1 to v.agg.0                                             
   say mpfx"0143I R/A ("i"):" left(aggnam.i,8) "-",                             
   "Len:" d2x(esdcumln.i,6) "Pad:" left(rggpad.i,8),                            
   "Csects:" right(tggcscnt.i,2)                                                
   end                                                                          
                                                                                
return 1                                                                        
                                                                                
                                                                                
/*********************************************************************/         
/* VTGG: Validate Target Aggregate Definition (TGGDEF.)              */         
/*********************************************************************/         
                                                                                
vtgg:     procedure expose cpfx mpfx xfn,                                       
          tggcscnt. tggcsnam. tggcsqua. tggcsmin. tggcsmax.,                    
          tggcsna2. hexchr v.epwild                                             
                                                                                
arg $agg, $targaggr                                                             
                                                                                
$taggwords = words($targaggr)                                                   
if $taggwords = 0 | $taggwords//2 ^= 0 then do                                  
   say mpfx"0008E T/A ("$agg") definition missing or invalid"                   
   return 0                                                                     
   end                                                                          
                                                                                
tggcscnt.$agg = $taggwords/2                                                    
                                                                                
do $def=1 to tggcscnt.$agg                                                      
                                                                                
   $taggoff = ($def-1)*2                                                        
   tggcsnam.$agg.$def = word($targaggr,$taggoff+1)                              
   tggcsna2.$agg.$def = left(tggcsnam.$agg.$def,8)                              
   $namlen = length(tggcsnam.$agg.$def)                                         
   if substr(tggcsnam.$agg.$def,$namlen,1) = v.epwild then do                   
      $namlen = $namlen - 1                                                     
      tggcsna2.$agg.$def = substr(tggcsnam.$agg.$def,1,$namlen)                 
      end                                                                       
   tggcsqua.$agg.$def = word($targaggr,$taggoff+2)                              
                                                                                
   if $namlen < 1 | $namlen > 8 then do                                         
      say mpfx"0013E T/A ("$agg") definition ("$def")",                         
      "csect name ("tggcsnam.$agg.$def") invalid"                               
      return 0                                                                  
      end                                                                       
                                                                                
   select                                                                       
      when tggcsqua.$agg.$def = "*" then nop                                    
      when tggcsqua.$agg.$def = "=" then nop                                    
      otherwise                                                                 
      if index(tggcsqua.$agg.$def,"-") > 0 then do                              
         parse var tggcsqua.$agg.$def $qua1 "-" $qua2                           
         parse value vhex($qua1,"T/A ("$agg")",                                 
         "definition ("$def") min length",6,8),                                 
         with ok tggcsmin.$agg.$def                                             
         if ^ok then return 0                                                   
         parse value vhex($qua2,"T/A ("$agg")",                                 
         "definition ("$def") max length",6,8),                                 
         with ok tggcsmax.$agg.$def                                             
         if ^ok then return 0                                                   
         if tggcsmin.$agg.$def > tggcsmax.$agg.$def then do                     
            say mpfx"0014E T/A ("$agg") definition ("$def")",                   
            "min length > max length"                                           
            return 0                                                            
            end                                                                 
         tggcsqua.$agg.$def = "-"                                               
         return 1                                                               
         end                                                                    
      else do                                                                   
         parse value vhex(tggcsqua.$agg.$def,,                                  
         "T/A ("$agg") definition ("$def") length",6,8),                        
         with ok tggcsmin.$agg.$def                                             
         if ^ok then return 0                                                   
         tggcsmax.$agg.$def = tggcsmin.$agg.$def                                
         tggcsqua.$agg.$def = "-"                                               
         end                                                                    
      end                                                                       
   end                                                                          
                                                                                
return 1                                                                        
                                                                                
                                                                                
/*********************************************************************/         
/* VHEX: Validate hex address and return DEC value                   */         
/*********************************************************************/         
                                                                                
vhex:                                                                           
                                                                                
parse arg $hex, $msgseg, $hexlen, $mult                                         
                                                                                
if $hex  = "" then do                                                           
   say mpfx"0029E" $msgseg "missing"                                            
   return 0                                                                     
   end                                                                          
                                                                                
if length($hex) > $hexlen | verify($hex,hexchr) > 0 then do                     
   say mpfx"0030E" $msgseg "("$hex") invalid"                                   
   return 0                                                                     
   end                                                                          
                                                                                
$hexdec = x2d($hex)                                                             
                                                                                
if $mult > 1 then do                                                            
   $mult = $mult%1                                                              
   if $hexdec ^= $hexdec%$mult*$mult then do                                    
      say mpfx"0031E" $msgseg "("$hex") not multiple of" $mult                  
      return 0                                                                  
      end                                                                       
   end                                                                          
                                                                                
return 1 $hexdec                                                                
                                                                                
                                                                                
/*********************************************************************/         
/* TXTLOAD:  Generate object string, ESD dictionary and RLD diction- */         
/*           ary from text deck                                      */         
/*                                                                   */         
/* ESD type code defs (DEC): 0=SD 1=LD 2=ER 4=PC 5=CM 6=XD 10=WX     */         
/*                                                                   */         
/* Routine reads text deck building (1) object code string for each  */         
/* SD and PC; (2) ESD dictionary for ESD items; and (3) RLD          */         
/* dictionary for RLD items.                                         */         
/*                                                                   */         
/* PREMISES:                                                         */         
/* 1. SD or PC ESD items precede any TXT records that build them.    */         
/* 2. There is one END card at the end of the text deck.             */         
/* 3. XD entries are not supported.                                  */         
/* 4. CM entries always have an address of 0.                        */         
/*                                                                   */         
/* ESD dictionary array (with sample entries) follows. (-) means     */         
/* field not applicable, and stem not assigned, for that ESD type.   */         
/* Columns headings below assume 'ESD' prefix.                       */         
/*                                                                   */         
/* I  NAM     TYP  ID  REF  ORG  LEN  TXT  DSP  EXR                  */         
/* 1  CSECT1    0   1    -    0  FFF text    0  epi                  */         
/* 2  EP1A      1   -    1    8    -    -    -    -                  */         
/* 3  CSECT2    0   2    - 1000   F0 text 1000  epi                  */         
/* 4  EP2A      1   -    3 1008    -    -    -    -                  */         
/* 5  EXTREF2   2   3    - 1010    -    -    -    -                  */         
/* 6  WXTREF2  10   4    - 1018    -    -    -    -                  */         
/* 7  (PC)      4   5    - 10F0   10 text 10F0  epi                  */         
/* 8  COM1      5   6    -    -   20    -    -    -                  */         
/*********************************************************************/         
                                                                                
txtload:                                                                        
                                                                                
arg $id, $epid, $fid                                                            
                                                                                
epcnt.$epid  = 0                                                                
epcno.$epid  = 0                                                                
esdcumln.$id = 0                                                                
$esdcsno     = 0                                                                
esdidx.$id   = 0                                                                
rldidx.$id   = 0                                                                
$com. = ""                                                                      
                                                                                
"EXECIO * DISKR" $fid "(STEM $TXTREC. FINIS"                                    
                                                                                
do recno=1 to $txtrec.0                                                         
                                                                                
   $txtrec = $txtrec.recno                                                      
   $txtrid = substr($txtrec,1,4)                                                
                                                                                
   select                                                                       
      when $txtrid = "2"x"END" then do                                          
         if recno ^= $txtrec.0 then do                                          
            say mpfx"0032E END card found before end of text file"              
            return 0                                                            
            end                                                                 
         end                                                                    
                                                                                
      when $txtrid = "2"x"TXT" then do                                          
         $txtesdid = c2d(substr($txtrec,15,2))                                  
         $txtaddr  = c2d(substr($txtrec,6,3))                                   
         $txtlen   = c2d(substr($txtrec,11,2))                                  
         parse value txtloc("TXT",$id,$txtesdid,$txtaddr,$txtlen),              
         with ok $ovcol $esdptr                                                 
         if ^ok then return 0                                                   
         $txtsub = substr($txtrec,17,$txtlen)                                   
         esdtxt.$id.$esdptr = overlay($txtsub,esdtxt.$id.$esdptr,$ovcol)        
         end                                                                    
                                                                                
      when $txtrid = "2"x"ESD" then do                                          
         $esdidbgn = c2d(substr($txtrec,15,2))                                  
         esdbyh = substr($txtrec,11,2)                                          
         esdbyt = c2d(esdbyh)                                                   
         esdent = esdbyt/16                                                     
                                                                                
         if esdent < 1 | esdent > 3 | esdbyt//16 ^= 0 then do                   
            say mpfx"0026E Invalid ESD byte count ("c2x(esdbyh)")"              
            return 0                                                            
            end                                                                 
                                                                                
         $esdidnew = 1                                                          
                                                                                
         do k=1 to esdent                                                       
            esdidx.$id = esdidx.$id + 1                                         
            $esdidx = esdidx.$id                                                
            $esdoff = (k-1)*16                                                  
            esdnam.$id.$esdidx = substr($txtrec,$esdoff+17,8)                   
            esdtyp.$id.$esdidx = ,                                              
            c2d(bitand(substr($txtrec,$esdoff+25,1),"f"x))                      
            esdorg.$id.$esdidx = c2d(substr($txtrec,$esdoff+26,3))              
                                                                                
            select                                                              
                                                                                
               /* SD */                                                         
                                                                                
               when esdtyp.$id.$esdidx = 0 then do                              
                  if ^esdid() then return 0                                     
                  esdlen.$id.$esdidx = c2d(substr($txtrec,$esdoff+30,3))        
                  call esdtxtgen                                                
                  esdexr.$id.$esdidx = epgen($epid,esdnam.$id.$esdidx,,         
                  esddsp.$id.$esdidx,"SD",esdlen.$id.$esdidx)                   
                  end                                                           
                                                                                
               /* LD */                                                         
                                                                                
               when esdtyp.$id.$esdidx = 1 then do                              
                  $refid = c2d(substr($txtrec,$esdoff+31,2))                    
                  $refptr = esdidx($id,$refid,0)                                
                  if $refptr = 0 then do                                        
                     say mpfx"0042E LD ("strip(esdnam.$id.$esdidx)")",          
                     "refers to undefined SD ("$refid")"                        
                     return 0                                                   
                     end                                                        
                  if esdorg.$id.$esdidx < esdorg.$id.$refptr then do            
                     say mpfx"0043E LD ("strip(esdnam.$id.$esdidx)")",          
                     "address ("esdorg.$id.$esdidx")",                          
                     "less than SD address",                                    
                     "("esdorg.$id.$refptr")"                                   
                     return 0                                                   
                     end                                                        
                  call epgen $epid, esdnam.$id.$esdidx,,                        
                  esdorg.$id.$esdidx - esdorg.$id.$refptr +,                    
                  esddsp.$id.$refptr,"LD",esdexr.$id.$refptr                    
                  end                                                           
                                                                                
               /* ER */                                                         
                                                                                
               when esdtyp.$id.$esdidx = 2 then do                              
                  if ^esdid() then return 0                                     
                  end                                                           
                                                                                
               /* PC */                                                         
                                                                                
               when esdtyp.$id.$esdidx = 4 then do                              
                  if ^esdid() then return 0                                     
                  esdlen.$id.$esdidx = c2d(substr($txtrec,$esdoff+30,3))        
                  call esdtxtgen                                                
                  esdexr.$id.$esdidx = epgen($epid,esdnam.$id.$esdidx,,         
                  esddsp.$id.$esdidx,"SD",esdlen.$id.$esdidx)                   
                  end                                                           
                                                                                
               /* CM */                                                         
                                                                                
               when esdtyp.$id.$esdidx = 5 then do                              
                  if ^esdid() then return 0                                     
                  esdlen.$id.$esdidx = c2d(substr($txtrec,$esdoff+30,3))        
                  $nam = esdnam.$id.$esdidx                                     
                  $com.$nam = esdlen.$id.$esdidx                                
                  end                                                           
                                                                                
               /* WX */                                                         
                                                                                
               when esdtyp.$id.$esdidx = 10 then do                             
                  if ^esdid() then return 0                                     
                  end                                                           
                                                                                
               otherwise                                                        
               say mpfx"0040E Unsupported ESD code",                            
               "("esdtyp.$id.$esdidx")"                                         
               return 0                                                         
               end                                                              
            end                                                                 
         end                                                                    
                                                                                
      when $txtrid = "2"x"RLD" then do                                          
         $newids = 1                                                            
         $rem = c2d(substr($txtrec,11,2))                                       
         $off = 16                                                              
         do while $rem > 0                                                      
            rldidx.$id = rldidx.$id + 1                                         
            $rldidx = rldidx.$id                                                
            if $newids then do                                                  
               $nxtrelid = c2d(substr($txtrec,$off+1,2))                        
               $nxtposid = c2d(substr($txtrec,$off+3,2))                        
               $off = $off + 4                                                  
               $rem = $rem - 4                                                  
               end                                                              
            $flag = bitand(substr($txtrec,$off+1,1),"FE"x)                      
            select                                                              
               when $flag = "c"x | $flag = "1c"x,                               
               then rldlen.$id.$rldidx = 4                                      
               when $flag = "8"x | $flag = "18"x,                               
               then rldlen.$id.$rldidx = 3                                      
               otherwise                                                        
               say mpfx"0024E Unsupported RLD flag ("c2x($flag)")"              
               return 0                                                         
               end                                                              
            rldvcon.$id.$rldidx = bitand($flag,"10"x) ^= "0"x                   
            rldrelid.$id.$rldidx = $nxtrelid                                    
            rldposid.$id.$rldidx = $nxtposid                                    
            rldaddr.$id.$rldidx  = c2d(substr($txtrec,$off+2,3))                
            $newids = (bitand(substr($txtrec,$off+1,1),"1"x) = "0"x)            
            $off = $off + 4                                                     
            $rem = $rem - 4                                                     
            end                                                                 
         end                                                                    
      otherwise                                                                 
      say mpfx"0033E Unrecognized record type at rcd" recno "of text"           
      return 0                                                                  
      end                                                                       
   end                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* Go through RLD dictionary and fill in:                             */        
/*                                                                    */        
/* RLDOVCOL  - Starting colno within csect for overlay                */        
/* RLDPOSPTR - ESD dct index that position esdid refers to            */        
/* RLDRELPTR - ESD dct index that relocation esdid refers to          */        
/* RLDTEXT   - Value (DEC) to be relocated (ADCONS only)              */        
/* RLDCMREF  - 1=RLD ER refers to CM in text deck                     */        
/**********************************************************************/        
                                                                                
do $i=1 to rldidx.$id                                                           
   parse value txtloc("RLD POSID",$id,rldposid.$id.$i,,                         
   rldaddr.$id.$i,rldlen.$id.$i),                                               
   with $ok rldovcol.$id.$i rldposptr.$id.$i                                    
   if ^$ok then return 0                                                        
   if rldvcon.$id.$i then do                                                    
      parse value extloc("RLD VCON RELID",$id,rldrelid.$id.$i),                 
      with $ok rldrelptr.$id.$i                                                 
      if ^$ok then return 0                                                     
      $relptr = rldrelptr.$id.$i                                                
      $nam = esdnam.$id.$relptr                                                 
      rldcmref.$id.$i = $com.$nam                                               
      end                                                                       
   else do                                                                      
      parse value secloc("RLD ADCON RELID",$id,rldrelid.$id.$i),                
      with $ok rldrelptr.$id.$i                                                 
      if ^$ok then return 0                                                     
      $posptr = rldposptr.$id.$i                                                
      rldtext.$id.$i = c2d(substr(esdtxt.$id.$posptr,rldovcol.$id.$i,,          
                                  rldlen.$id.$i))                               
      end                                                                       
   end                                                                          
                                                                                
return 1                                                                        
                                                                                
                                                                                
/*********************************************************************/         
/* ESDID: Get next ESDID for ESD entry                               */         
/*                                                                   */         
/* ESDID is got from initial value found in ESD card, if this is     */         
/* the first call for an ESDID, or derived by incrementing previous  */         
/* values.                                                           */         
/*                                                                   */         
/* Assigned: $ESDIDNXT   ESDID.x.y $ESDIDNEW                         */         
/*********************************************************************/         
                                                                                
esdid:                                                                          
                                                                                
if $esdidnew then do                                                            
   $esdidnxt = $esdidbgn                                                        
   $esdidnew = 0                                                                
   end                                                                          
                                                                                
else $esdidnxt = $esdidnxt + 1                                                  
                                                                                
if $esdidnxt < 1 then do                                                        
   say mpfx"0027E ESDID ("$esdidnxt") invalid"                                  
   return 0                                                                     
   end                                                                          
                                                                                
if esdidx($id,$esdidnxt,1) > 0 then do                                          
   say mpfx"0028E ESDID ("$esdidnxt") already assigned"                         
   return 0                                                                     
   end                                                                          
                                                                                
esdid.$id.$esdidx = $esdidnxt                                                   
return 1                                                                        
                                                                                
                                                                                
/*********************************************************************/         
/* ESDTXTGEN: Fill in esdtxt.$id. field                              */         
/*********************************************************************/         
                                                                                
esdtxtgen:                                                                      
                                                                                
$esdlendw = ((esdlen.$id.$esdidx+7)%8)*8                                        
esdtxt.$id.$esdidx = copies(cspadchr,$esdlendw)                                 
esddsp.$id.$esdidx = esdcumln.$id                                               
esdcumln.$id = esdcumln.$id + $esdlendw                                         
$esdcsno = $esdcsno + 1                                                         
esdcsno.$esdidx = $esdcsno                                                      
return                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* RLCHDRS: Gen RELOCATE listing headings                           */          
/*********************************************************************/         
                                                                                
rlchdrs:                                                                        
                                                                                
                                                                                
h.1.1 = "0" ||,                                                                 
      center("--- EXTERNAL REFERENCE RESOLUTION ---",linwid)                    
                                                                                
parse value modhdrs(1,2,2) with $hdrsadd $linsadd                               
                                                                                
$i = $hdrsadd + 2                                                               
                                                                                
h.1.$i = "0" ||,                                                                
      center(,                                                                  
      center("",8),                                                             
      center("",8),                                                             
      center("REFERS",8),                                                       
      center("AT",8),                                                           
      center("IN",8),,                                                          
      linwid)                                                                   
                                                                                
$i = $i + 1                                                                     
                                                                                
h.1.$i = " " ||,                                                                
      center(,                                                                  
      center("AGGR",8),                                                         
      center("R/AGGR",8),                                                       
      center("TO",8),                                                           
      center("MODULE",8),                                                       
      center("MODULE",8),,                                                      
      linwid)                                                                   
                                                                                
$i = $i + 1                                                                     
                                                                                
h.1.$i = " " ||,                                                                
      center(,                                                                  
      center("NAME",8),                                                         
      center("LOCATION",8),                                                     
      center("SYMBOL",8),                                                       
      center("OFFSET",8),                                                       
      center("SECTION",8),,                                                     
      linwid)                                                                   
                                                                                
$i = $i + 1                                                                     
                                                                                
h.1.$i = " " ||,                                                                
      center(,                                                                  
      center("",8,"-"),                                                         
      center("",8,"-"),                                                         
      center("",8,"-"),                                                         
      center("",8,"-"),                                                         
      center("",8,"-"),,                                                        
      linwid)                                                                   
                                                                                
h.1.0 =  $hdrsadd + 5                                                           
hlin.1 = $linsadd + 7                                                           
endrep.1 = 1                                                                    
return                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* RELOC: Relocate text in RA object string                         */          
/*********************************************************************/         
                                                                                
reloc:                                                                          
                                                                                
arg $id, $ep1, $ep2                                                             
                                                                                
$relocund. = 0                                                                  
rldnew.$id = ""                                                                 
$relocerr = 0                                                                   
                                                                                
do $i=1 to rldidx.$id                                                           
                                                                                
   $ovcol =  rldovcol.$id.$i                                                    
   $posptr = rldposptr.$id.$i                                                   
   $relptr = rldrelptr.$id.$i                                                   
                                                                                
   if rldvcon.$id.$i then do                                                    
      $extnam = esdnam.$id.$relptr                                              
      parse value eploc($ep1,$ep2,$extnam,rldcmref.$id.$i),                     
      with $ok $ep1ptr $ep1stat                                                 
      if ^$ok then do                                                           
         if op_extrf then call prt 1, left(aggnam.$id,8),                       
                               right(d2x(rldaddr.$id.$i),8),                    
                               left($extnam,8),                                 
                               center($ep1stat,17,"*")                          
         if ^$relocund.$extnam then do                                          
            call logsumm "0120E" left(aggnam.$id,8),                            
            "("left($extnam,8)") not resolved",                                 
            "("$ep1stat")"                                                      
            $relocund.$extnam = 1                                               
            end                                                                 
         $relocerr = 1                                                          
         end                                                                    
      else do                                                                   
         if op_extrf then do                                                    
            if eptyp.$ep1.$ep1ptr = "LD" then $csptr = epref.$ep1.$ep1ptr       
            else $csptr = $ep1ptr                                               
            call prt 1, left(aggnam.$id,8),                                     
                        right(d2x(rldaddr.$id.$i),8),                           
                        left($extnam,8),                                        
                        right(d2x(epdsp.$ep1.$ep1ptr),8),                       
                        left(epnam.$ep1.$csptr,8)                               
            end                                                                 
         call reloc_ins d2c(epdsp.$ep1.$ep1ptr+eplower.$ep1,,                   
         rldlen.$id.$i)                                                         
         end                                                                    
      end                                                                       
                                                                                
   else do                                                                      
      call reloc_ins d2c(+rldtext.$id.$i,                                       
                         -esdorg.$id.$relptr,                                   
                         +esddsp.$id.$relptr,                                   
                         +eplower.$ep2,,                                        
                         rldlen.$id.$i)                                         
      end                                                                       
   end                                                                          
                                                                                
esdglom.$id = ""                                                                
do $i=1 to esdidx.$id                                                           
   if esdtyp.$id.$i = 0 | esdtyp.$id.$i = 4 then,                               
   esdglom.$id = esdglom.$id || esdtxt.$id.$i                                   
   end                                                                          
                                                                                
return ^$relocerr                                                               
                                                                                
                                                                                
/*********************************************************************/         
/* RELOC_INS: Insert relocated text in object string                 */         
/*********************************************************************/         
                                                                                
reloc_ins:                                                                      
                                                                                
parse arg $text                                                                 
                                                                                
esdtxt.$id.$posptr = overlay($text,esdtxt.$id.$posptr,$ovcol)                   
if modrld then rldnew.$id = rldnew.$id || d2c(rldlen.$id.$i-1) ||,              
               d2c($ovcol-1+esddsp.$id.$posptr+eplower.$ep2,3)                  
return                                                                          
                                                                                
/*********************************************************************/         
/* SECLOC: Get ESD ptr for csect ESDID                               */         
/*********************************************************************/         
                                                                                
secloc:   procedure expose cpfx mpfx xfn,                                       
        esdidx. esdtyp. esdid.                                                  
                                                                                
arg $desc, $id, $esdid                                                          
                                                                                
$esdptr = esdidx($id,$esdid,0)                                                  
                                                                                
if $esdptr = 0 then do                                                          
   say mpfx"0034E" $desc "ESDID reference ("$esdid") invalid"                   
   return 0                                                                     
   end                                                                          
                                                                                
if esdtyp.$id.$esdptr ^= 0 & esdtyp.$id.$esdptr ^= 4 then do                    
   say mpfx"0035E" $desc "ESDID ("$esdid") type ("esdtyp.$id.$esdptr")",        
   "not CSECT"                                                                  
   return 0                                                                     
   end                                                                          
                                                                                
return 1 $esdptr                                                                
                                                                                
                                                                                
/*********************************************************************/         
/* EXTLOC: Get ESD ptr for EXT REF ESDID                             */         
/*********************************************************************/         
                                                                                
extloc:   procedure expose cpfx mpfx xfn,                                       
        esdidx. esdtyp. esdid.                                                  
                                                                                
arg $desc, $id, $esdid                                                          
                                                                                
$esdptr = esdidx($id,$esdid,0)                                                  
                                                                                
if $esdptr = 0 then do                                                          
   say mpfx"0036E" $desc "ESDID reference ("$esdid") invalid"                   
   return 0                                                                     
   end                                                                          
                                                                                
if esdtyp.$id.$esdptr ^= 2 then do                                              
   say mpfx"0037E" $desc "ESDID ("$esdid") type ("esdtyp.$id.$esdptr")",        
   "not EXTREF"                                                                 
   return 0                                                                     
   end                                                                          
                                                                                
return 1 $esdptr                                                                
                                                                                
                                                                                
/*********************************************************************/         
/* EPLOC: Get EP ptr given name                                      */         
/*********************************************************************/         
                                                                                
eploc:    procedure expose cpfx mpfx xfn,                                       
          epcnt. epnam. epdsp. epwidth. eptyp. eplen. eplower. epupper.         
                                                                                
arg $ep1, $ep2, $nam, $com                                                      
                                                                                
$err = ""                                                                       
                                                                                
do i=1 to epcnt.$ep1                                                            
   if $nam = epnam.$ep1.i then do                                               
      $eploc = eplower.$ep1 + epdsp.$ep1.i                                      
                                                                                
      if $com ^= "" then do                                                     
         if eptyp.$ep1.i = "CM" then do                                         
            if $com > eplen.$ep1.i then,                                        
            $err = $err"NO FIT "d2x($com)"/"d2x(eplen.$ep1.i)"-"                
            end                                                                 
         else $err = $err"NOT CM-"                                              
         end                                                                    
                                                                                
      else do                                                                   
         if eptyp.$ep1.i ^= "SD" & eptyp.$ep1.i ^= "LD" then,                   
         $err = $err"NOT SD/LD-"                                                
         end                                                                    
                                                                                
      if epdsp.$ep1.i < 0 | epdsp.$ep1.i > epwidth.$ep1 then,                   
      $err = $err"EXCLUDED-"                                                    
                                                                                
      if $eploc >= eplower.$ep2 & $eploc < epupper.$ep2 then,                   
      $err = $err"INSIDE T/A-"                                                  
                                                                                
      if $err ^= "" then return 0 0 substr($err,1,length($err)-1)               
      else return 1 i                                                           
      end                                                                       
   end                                                                          
                                                                                
return 0 0 "UNDEFINED"                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* EPGEN: Add EP to EP tables                                        */         
/*********************************************************************/         
                                                                                
epgen:    procedure expose cpfx mpfx xfn,                                       
          epcnt. epnam. epdsp. eptyp. epref. epcno. eplen.                      
                                                                                
arg $agg, $nam, $aggdsp, $typ, $lenref                                          
                                                                                
epcnt.$agg = epcnt.$agg + 1                                                     
$new = epcnt.$agg                                                               
                                                                                
epnam.$agg.$new = $nam                                                          
epdsp.$agg.$new = $aggdsp                                                       
eptyp.$agg.$new = $typ                                                          
                                                                                
if $typ = "LD" then do                                                          
   epref.$agg.$new = $lenref                                                    
   end                                                                          
                                                                                
else do                                                                         
   eplen.$agg.$new = $lenref                                                    
   epcno.$agg = epcno.$agg + 1                                                  
   epcno.$agg.$new = epcno.$agg                                                 
   end                                                                          
                                                                                
return $new                                                                     
                                                                                
                                                                                
/*********************************************************************/         
/* ESDIDX: Get ESD dictionary index for ESDID value                  */         
/*********************************************************************/         
                                                                                
esdidx:   procedure expose cpfx mpfx xfn,                                       
        esdidx. esdtyp. esdid.                                                  
                                                                                
arg $id, $esdid, $minus                                                         
                                                                                
do i = 1 to esdidx.$id - $minus                                                 
   if esdtyp.$id.i = 1 then iterate i                                           
   if esdid.$id.i = $esdid then return i                                        
   end                                                                          
return 0                                                                        
                                                                                
                                                                                
/*********************************************************************/         
/* SETRC: Set return code                                            */         
/*********************************************************************/         
                                                                                
setrc:                                                                          
arg $rc                                                                         
if $rc > xrc then xrc = $rc                                                     
return                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* PRT: Print a detail line in the analysis report                   */         
/*********************************************************************/         
                                                                                
prt:                                                                            
                                                                                
arg $repid, $prtdtl                                                             
                                                                                
if newsec.$repid | lincnt.$repid >= linmax.$repid | endrep.$repid then do       
                                                                                
   if pagno.$repid > 0 then do                                                  
      if endrep.$repid then call footer $repid, "END"                           
      else call footer $repid, "CONTINUED"                                      
      end                                                                       
                                                                                
   pagno.$repid = pagno.$repid + 1                                              
                                                                                
   if newsec.$repid then do                                                     
      secnum.$repid = secnum.$repid + 1                                         
      secpag.$repid = 1                                                         
      end                                                                       
   else secpag.$repid = secpag.$repid + 1                                       
                                                                                
   if op_nogen then $proc = "NOGEN"                                             
   else $proc = "GEN"                                                           
                                                                                
   if v.epwild = "" then epwlit = "SUPPRESSED"                                  
   else epwlit = "CHAR("v.epwild")"                                             
                                                                                
   h.0.2 = "0" ||,                                                              
   center(,                                                                     
   left("RUNDATE",8,".") || right(xdate,11,".")        || hs ||,                
   left("B/O-DIR",8,".") || right(bckfid,20,".")       || hs ||,                
   left("CFG-FID",8,".") || right(cfgfid,20,".")       || hs ||,                
   left("EPWILD",8,".")  || right(epwlit,11,"."),,                              
   linwid)                                                                      
                                                                                
   h.0.3 = " " ||,                                                              
   center(,                                                                     
   left("RUNTIME",8,".") || right(xtime,11,".")                   ||hs||,       
   left("MODARCH",8,".") || right(v.modgen,20,".")                ||hs||,       
   left("PGM-KEY",8,".") || right(pgmkey,20,".")                  ||hs||,       
   left("SECTION",8,".") || right(secnum.$repid"-"secpag.$repid,11,"."),,       
   linwid)                                                                      
                                                                                
   h.0.4 = " " ||,                                                              
   center(,                                                                     
   left("RUNUSER",8,".") || right(xuser,11,".")                   ||hs||,       
   left("PROCESS",8,".") || right($proc,20,".")                   ||hs||,       
   left("CSPADCHR",8,".")|| right(v.cspadc,20,".")                ||hs||,       
   left("PAGE",8,".") ||    right(pagno.$repid,11,"."),,                        
   linwid)                                                                      
                                                                                
   "EXECIO" h.0.0 "DISKW" repfid.$repid "(STEM H.0."                            
   lincnt.$repid = hlin.0 + 2                                                   
   do $prti=1 to v.uhdr.0                                                       
      if $prti = 1 then $orec = strip("0"center(v.uhdr.$prti,linwid),"T")       
      else              $orec = strip(" "center(v.uhdr.$prti,linwid),"T")       
      "EXECIO 1 DISKW" repfid.$repid "(VAR $OREC"                               
      end                                                                       
   if v.uhdr.0 > 0 then lincnt.$repid = lincnt.$repid + v.uhdr.0 + 1            
   "EXECIO" h.$repid.0 "DISKW" repfid.$repid "(STEM H."$repid"."                
   lincnt.$repid = hlin.$repid + lincnt.$repid                                  
   newsec.$repid = 0                                                            
   endrep.$repid = 0                                                            
   end                                                                          
                                                                                
prtdtlln.$repid = length($prtdtl)                                               
prtdtlof.$repid = (linwid-prtdtlln.$repid)%2 + 2                                
$orec = strip(overlay($prtdtl,"",prtdtlof.$repid),'t')                          
"EXECIO 1 DISKW" repfid.$repid "(VAR $OREC"                                     
lincnt.$repid = lincnt.$repid + 1                                               
return                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* FOOTER: Print footers at end-of-page                              */         
/*********************************************************************/         
                                                                                
footer:                                                                         
                                                                                
arg $repid, footer.2                                                            
                                                                                
footpad = left("",prtdtlof.$repid-1)                                            
footer.1 = copies("-",prtdtlln.$repid)                                          
footer.1 = footpad||footer.1                                                    
footer.2 = footpad||footer.2                                                    
"EXECIO 2 DISKW" repfid.$repid "(STEM FOOTER."                                  
return                                                                          
                                                                                
                                                                                
/* EDDSK routine ----------------------------------------------------*/         
                                                                                
eddsk:    procedure expose cpfx mpfx xfn,                                       
          lincnt. linmax. eddskidx. dskidx dskusr. dskdev.                      
                                                                                
arg $repid                                                                      
                                                                                
if eddskidx.$repid < dskidx | lincnt.$repid >= linmax.$repid then do            
   if eddskidx.$repid = dskidx then $cont = "+"                                 
   else $cont = ""                                                              
   eddskidx.$repid = dskidx                                                     
   return right($cont||dskidx,5) dskusr.dskidx dskdev.dskidx                    
   end                                                                          
                                                                                
else return left("",19)                                                         
                                                                                
                                                                                
/*********************************************************************/         
/* EDFID:  Edit fileid for insertion in print line                   */         
/*********************************************************************/         
                                                                                
edfid:    procedure expose cpfx mpfx xfn,                                       
          lincnt. linmax. eddskidx. edmodidx. modidx dskidx,                    
          modfn modft modfm modda modti modxa modrld                            
                                                                                
arg $repid                                                                      
                                                                                
$newfil = (eddskidx.$repid ^= dskidx) | (edmodidx.$repid ^= modidx)             
                                                                                
if $newfil | lincnt.$repid >= linmax.$repid then do                             
   edmodidx.$repid = modidx                                                     
   return left(modfn,8) left(modft,8) modfm modda modti,                        
          substr("-NX",modxa+2,1)substr("-NR",modrld+2,1)                       
   end                                                                          
                                                                                
else return left("",37)                                                         
                                                                                
                                                                                
/*********************************************************************/         
/* EDMSPL: Edit map splice                                           */         
/*********************************************************************/         
                                                                                
edmspl:                                                                         
                                                                                
parse arg $repid, $entry                                                        
                                                                                
if $repid = 0 then return left("",45,v.nullc)                                   
if $repid > 0 then $sign = "+"                                                  
if $repid < 0 then $sign = "-"                                                  
                                                                                
if length($entry) = 20 then do                                                  
   return $sign ||,                                                             
          substr($entry,1,8),                                                   
          c2x(substr($entry,9,4)),                                              
          c2x(substr($entry,13,4)),                                             
          c2x(substr($entry,17,4)),                                             
          left("",8)                                                            
   end                                                                          
                                                                                
else do                                                                         
   return $sign ||,                                                             
          substr($entry,1,8),                                                   
          c2x(substr($entry,9,4)),                                              
          c2x(substr($entry,13,4)),                                             
          c2x(substr($entry,17,4)),                                             
          c2x(substr($entry,21,4))                                              
   end                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* EDRSPL: Edit RLD splice                                           */         
/*********************************************************************/         
                                                                                
edrspl:                                                                         
                                                                                
parse arg $repid, $entry                                                        
                                                                                
if $repid = 0 then return left("",12,v.nullc)                                   
if $repid > 0 then $sign = "+"                                                  
if $repid < 0 then $sign = "-"                                                  
                                                                                
if length($entry) = 4 then do                                                   
   return $sign ||,                                                             
          left(c2x(substr($entry,1,1)) c2x(substr($entry,2,3)),11)              
   end                                                                          
                                                                                
else do                                                                         
   return $sign ||,                                                             
          left(c2x(substr($entry,1,1)) c2x(substr($entry,2,4)),11)              
   end                                                                          
                                                                                
/*********************************************************************/         
/* EDMSG:  Edit 73-char msg for report insertion                     */         
/*********************************************************************/         
                                                                                
edmsg:    procedure                                                             
                                                                                
arg $msg                                                                        
return left($msg,73)                                                            
                                                                                
                                                                                
/*********************************************************************/         
/* OUTCHK: Erase or flag extant output file                          */         
/*********************************************************************/         
                                                                                
outchk:                                                                         
                                                                                
arg $fid,$erase                                                                 
                                                                                
signal off error                                                                
"ESTATE" $fid                                                                   
signal on error                                                                 
$statrc = rc                                                                    
                                                                                
if $statrc = 0 then do                                                          
                                                                                
   if $erase then do                                                            
      "ERASE" $fid                                                              
      say mpfx"0018I File ("$fid") erased"                                      
      return 1                                                                  
      end                                                                       
   else do                                                                      
      say mpfx"0022E Output file ("$fid") already exists"                       
      return 0                                                                  
      end                                                                       
   end                                                                          
                                                                                
else return 1                                                                   
                                                                                
                                                                                
/*********************************************************************/         
/* CERASE: Erase file if erase flag set; o/w no action.              */         
/*********************************************************************/         
                                                                                
cerase:                                                                         
                                                                                
arg $fid,$erase                                                                 
                                                                                
if $erase then do                                                               
   signal off error                                                             
   "ESTATE" $fid                                                                
   signal on error                                                              
   $statrc = rc                                                                 
                                                                                
   if $statrc = 0 then do                                                       
      "ERASE" $fid                                                              
      say mpfx"0021I File ("$fid") erased"                                      
      end                                                                       
   end                                                                          
                                                                                
return 1                                                                        
                                                                                
                                                                                
/**********************************************************************/        
/* VSTR: Validate string length                                       */        
/**********************************************************************/        
                                                                                
vstr:     procedure expose cpfx mpfx xfn                                        
                                                                                
parse arg $dsc, $val, $min, $max                                                
                                                                                
if length($val) >= $min & length($val) <= $max then return 1                    
                                                                                
else do                                                                         
   say mpfx"0011E" $dsc "missing or invalid ("$min"-"$max")"                    
   return 0                                                                     
   end                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* VNUM: Validate numeric parameter                                   */        
/**********************************************************************/        
                                                                                
vnum:     procedure expose cpfx mpfx xfn,                                       
          numchr                                                                
                                                                                
parse arg dsc, val, min, max                                                    
                                                                                
if val = "" | verify(val,numchr) > 0 then do                                    
   say mpfx"0140E" dsc "missing or invalid"                                     
   return 0                                                                     
   end                                                                          
                                                                                
if val < min | val > max then do                                                
   say mpfx"0141E" dsc "range error ("min"-"max")"                              
   return 0                                                                     
   end                                                                          
                                                                                
return 1                                                                        
                                                                                
                                                                                
/**********************************************************************/        
/* VFNT: Validate filename/filetype syntax                            */        
/**********************************************************************/        
                                                                                
vfnt:     procedure expose cpfx mpfx xfn,                                       
          fidchr                                                                
                                                                                
parse arg $dsc, $fn                                                             
                                                                                
$fn = strip($fn,'b')                                                            
                                                                                
if length($fn)>0 & length($fn)<=8 & verify($fn,fidchr)=0 then return 1          
                                                                                
else do                                                                         
   if $fn = "" then $lit = ""                                                   
   else $lit = "("$fn")"                                                        
   say mpfx"0015E" $dsc "invalid" $lit                                          
   return 0                                                                     
   end                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* VWLD: Validate wildcard fn/ft syntax                               */        
/**********************************************************************/        
                                                                                
vwld:     procedure expose cpfx mpfx xfn,                                       
          fidwld                                                                
                                                                                
parse arg $dsc, $fn                                                             
                                                                                
if $fn ^= "" & length($fn) <= 8 & verify($fn,fidwld) = 0 then return 1          
                                                                                
else do                                                                         
   if $fn = "" then $lit = ""                                                   
   else $lit = "("$fn")"                                                        
   say mpfx"0009E" $dsc "invalid" $lit                                          
   return 0                                                                     
   end                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* FNDFIL: Locate file given 2 or 3 token fileid                      */        
/**********************************************************************/        
                                                                                
fndfil:   procedure expose cpfx mpfx xfn,                                       
          fidchr cmsdisk.                                                       
                                                                                
parse arg dsc, fid                                                              
fid = space(fid)                                                                
parse var fid fn ft fm                                                          
res = 1                                                                         
                                                                                
if words(fid) < 2 | words(fid) > 3 |,                                           
   length(fn) > 8 |,                                                            
   verify(fn,fidchr) > 0 |,                                                     
   length(ft) > 8 |,                                                            
   verify(ft,fidchr) > 0 |,                                                     
   ^cmsdisk.fm then do                                                          
   say mpfx"0023E" dsc "fileid missing or invalid"                              
   return 0                                                                     
   end                                                                          
                                                                                
if fm = "" then fm = "*"                                                        
                                                                                
q1 = queued()                                                                   
signal off error                                                                
"L" fn ft fm "(LIFO NOH DA"                                                     
signal on error                                                                 
lstrc = rc                                                                      
                                                                                
if lstrc ^= 0 then do                                                           
   say mpfx"0044E" dsc "file not found ("lstrc")"                               
   return 0                                                                     
   end                                                                          
                                                                                
do i=1 to queued() - q1                                                         
   pull . . fm .                                                                
   end                                                                          
                                                                                
return 1 fn ft fm                                                               
                                                                                
                                                                                
/**********************************************************************/        
/* ACCLIST: Gen lists of accessed disks                               */        
/**********************************************************************/        
                                                                                
acclist:    procedure expose cpfx mpfx xfn,                                     
            cmsdisk. cmsdiskrw. cmsused.                                        
                                                                                
cmsused. = 0                                                                    
cmsdisk. = 0                                                                    
cmsdiskrw. = 0                                                                  
                                                                                
q1 = queued()                                                                   
"Q DISK * (LIFO"                                                                
lines = queued() - q1                                                           
                                                                                
do i=1 to lines                                                                 
   pull qdiskresp                                                               
   if i = lines then iterate i                                                  
   parse value substr(qdiskresp,8) with . letter status .                       
   letter = substr(letter,1,1)                                                  
   cmsdisk.letter = 1                                                           
   if status = "R/W" then cmsdiskrw.letter = 1                                  
   end                                                                          
                                                                                
return                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* VACC: Validate filemode letter                                     */        
/**********************************************************************/        
                                                                                
vacc:       procedure expose cpfx mpfx xfn,                                     
            cmsdisk. cmsdiskrw. cmsused. alfchr                                 
                                                                                
arg dsc, letter, rw                                                             
                                                                                
if length(letter) /= 1 | verify(letter,alfchr) > 0 then do                      
   say mpfx"0041E" dsc "("letter") invalid"                                     
   return 0                                                                     
   end                                                                          
                                                                                
if ^cmsdisk.letter then do                                                      
   say mpfx"0019E" dsc "("letter") not accessed"                                
   return 0                                                                     
   end                                                                          
                                                                                
if rw & ^cmsdiskrw.letter then do                                               
   say mpfx"0020E" dsc "("letter") not R/W"                                     
   return 0                                                                     
   end                                                                          
                                                                                
cmsused.letter = 1                                                              
                                                                                
return 1                                                                        
                                                                                
                                                                                
/* VTMP routine ------------------------------------------------------*/        
                                                                                
vtmp:   procedure expose mpfx cpfx xfn,                                         
        alfchr cmsused.                                                         
                                                                                
arg letter                                                                      
                                                                                
if length(letter) ^= 1 |,                                                       
   verify(letter,alfchr) > 0 |,                                                 
   verify(letter,"SY","M") > 0 then do                                          
   say mpfx"0060E Invalid TMPFM specified:" letter                              
   return 0                                                                     
   end                                                                          
                                                                                
if cmsused.letter then do                                                       
   say mpfx"0061E TMPFM in use:" letter                                         
   return 0                                                                     
   end                                                                          
                                                                                
return 1                                                                        
                                                                                
                                                                                
/**********************************************************************/        
/* MODWRT: Write new module file                                      */        
/*                                                                    */        
/* -Close input if being read                                         */        
/* -Assign b/o sequence no for b/o fid                                */        
/* -If gen, save module using b/o fid                                 */        
/* -Add b/o fid to directory, even if nogen, so we can collect stats, */        
/*  using FINIS option to be sure update reflected before poss erase  */        
/* -If gen, ERASE original                                            */        
/* -Determine where to read module for splicing (b/o or target)       */        
/* -Rewrite text rcds with updates                                    */        
/* -Write new map record(s)                                           */        
/* -Rewrite HST record(s)                                             */        
/* -Close input (and output, if gen) files                            */        
/*                                                                    */        
/* (B/O directory format:)                                            */        
/*                                                                    */        
/* 1  2  3  4   5  6   7   8   9    10   11  12  13  14  15  16       */        
/* GN D1 T1 OWN DV MFN MFT MNO MUPD MUPT MLR MBL MBZ BFN BFT RS       */        
/**********************************************************************/        
                                                                                
modwrt:                                                                         
                                                                                
arg $ep1                                                                        
                                                                                
if modopenr then do                                                             
   "FINIS" modrdfid                                                             
   modopenr = 0                                                                 
   end                                                                          
                                                                                
if op_nosav then do                                                             
   bomft = nosavft                                                              
   bomfid = v.bckfn bomft v.bckfm                                               
   if ^op_nogen then do                                                         
      signal off error                                                          
      "ERASE" bomfid                                                            
      signal on error                                                           
      end                                                                       
   end                                                                          
                                                                                
else do                                                                         
   bomft  = "+"right(bckseq,7,0)                                                
   bomfid = v.bckfn bomft v.bckfm                                               
   bckseq = bckseq + 1                                                          
   end                                                                          
                                                                                
if ^op_nogen then "COPY" modfn modft modfm bomfid "(OLDD"                       
                                                                                
$rec = ^op_nogen,                                                               
       statdat,                                                                 
       stattim,                                                                 
       dskusr.dskidx,                                                           
       dskdev.dskidx,                                                           
       left(modfn,8),                                                           
       left(modft,8),                                                           
       substr(modfm,2,1),                                                       
       modda,                                                                   
       modti,                                                                   
       right(modlr,5),                                                          
       right(modbc,5),                                                          
       right(modblksz,4),                                                       
       left(v.bckfn,8),                                                         
       left(bomft,8),                                                           
       "0"                                                                      
                                                                                
"EXECIO 1 DISKW" bckfid 0 "F" length($rec) "(VAR $REC FINIS"                    
                                                                                
if ^op_nogen then do                                                            
   "ERASE" modfn modft modfm                                                    
   modrdfid = bomfid                                                            
   end                                                                          
                                                                                
else do                                                                         
   modrdfid = modfid                                                            
   end                                                                          
                                                                                
newmodrc = 0                                                                    
$modrec = newhdr                                                                
call modput                                                                     
                                                                                
oldtxtsz = 0                                                                    
                                                                                
do txtidx = 1 to oldtxtrc                                                       
   if ^modget(oldtxtrn+txtidx-1,"TXT",modrdfid) then do                         
      return 0                                                                  
      end                                                                       
   $modrecl  = length($modrec)                                                  
   oldtxtsz = oldtxtsz + $modrecl                                               
   recdsplo = (txtidx-1)*65535                                                  
   recdsphi = recdsplo + $modrecl                                               
                                                                                
   do aggidx = 1 to v.agg.0                                                     
      if ^raselect.aggidx then iterate aggidx                                   
      $ra = aggidx + 1                                                          
      intvlbgn = max(recdsplo,eplower.$ra-eplower.$ep1)                         
      intvlend = min(recdsphi,epupper.$ra-eplower.$ep1)                         
      intvllen = intvlend-intvlbgn                                              
                                                                                
      if intvllen > 0 then do                                                   
         splraoff = intvlbgn-(eplower.$ra-eplower.$ep1)                         
         spltxoff = intvlbgn-recdsplo                                           
                                                                                
         $modrec = overlay(,                                                    
                  substr(esdglom.aggidx,splraoff+1,intvllen),,                  
                  $modrec,,                                                     
                  spltxoff+1)                                                   
                                                                                
         if op_splic then call prt 1, left(aggnam.aggidx,8),                    
         edmspl(0) edrspl(0) edtspl(1)                                          
         end                                                                    
      end                                                                       
                                                                                
   call modput                                                                  
   end                                                                          
                                                                                
if oldtxtsz ^= modlen then do                                                   
   call logsumm "0121A TXT len ("right(oldtxtsz,7)") <> mod len",               
   "("right(modlen,7)")"                                                        
   return 0                                                                     
   end                                                                          
                                                                                
/*************************/                                                     
/* Rewrite map record(s) */                                                     
/*************************/                                                     
                                                                                
$off = 1                                                                        
$rem = length(newmap)                                                           
do while $rem > 0                                                               
   $use = min($rem,65535)                                                       
   $modrec = substr(newmap,$off,$use)                                           
   call modput                                                                  
   $off = $off + $use                                                           
   $rem = $rem - $use                                                           
   end                                                                          
                                                                                
/*************************/                                                     
/* Rewrite RLD record(s) */                                                     
/* (NOP if newrld = "")  */                                                     
/*************************/                                                     
                                                                                
$off = 1                                                                        
$rem = length(newrld)                                                           
do while $rem > 0                                                               
   $use = min($rem,65535)                                                       
   $modrec = substr(newrld,$off,$use)                                           
   call modput                                                                  
   $off = $off + $use                                                           
   $rem = $rem - $use                                                           
   end                                                                          
                                                                                
/*************************/                                                     
/* Rewrite HST record(s) */                                                     
/*************************/                                                     
                                                                                
do $i=1 to oldhstrc                                                             
   if ^modget(oldhstrn+$i-1,"HST",modrdfid) then return 0                       
   call modput                                                                  
   end                                                                          
                                                                                
/**********************************************************/                    
/* CLOSE input module                                     */                    
/**********************************************************/                    
                                                                                
"FINIS" modrdfid                                                                
modopenr = 0                                                                    
                                                                                
/************************************/                                          
/* CLOSE processing for output file */                                          
/************************************/                                          
                                                                                
if ^op_nogen then do                                                            
   "FINIS" modfid                                                               
   modopenw = 0                                                                 
   if op_nosav then "ERASE" bomfid                                              
   end                                                                          
                                                                                
splrec = left(cfgfn,8) statdat substr(stattim,1,4),                             
     dskusr.dskidx dskdev.dskidx,                                               
     left(modfn,8) left(modft,8) substr(modfm,2,1)                              
                                                                                
splrec = splrec,                                                                
     "T("right(oldtxtrc,6)")",                                                  
     "MI("right(newmapec,6)","edplus(newmapec-oldmapec)")",                     
     "MR("right(newmaprc,6)","edplus(newmaprc-oldmaprc)")",                     
     "RI("right(newrldec,6)","edplus(newrldec-oldrldec)")",                     
     "RR("right(newrldrc,1)","edplus(newrldrc-oldrldrc)")",                     
     "H("right(oldhstrc,6)")",                                                  
     "*("right(newmodrc,6)","edplus(newmodrc-oldmodrc)")"                       
                                                                                
"EXECIO 1 DISKW" splfid 0 "F" length(splrec) "(VAR SPLREC"                      
splrc = splrc + 1                                                               
return 1 bomft                                                                  
                                                                                
                                                                                
/*********************************************************************/         
/* EDTSPL: Edit text splice display                                  */         
/*********************************************************************/         
                                                                                
edtspl:                                                                         
                                                                                
arg $repid                                                                      
                                                                                
if $repid = 0 then return left("",23,v.nullc)                                   
                                                                                
return right(d2x(modfrdec+intvlbgn),8),                                         
       right(newmodrc,4),                                                       
       right(d2x(spltxoff),4),                                                  
       right(d2x(intvllen),4)                                                   
                                                                                
                                                                                
/*********************************************************************/         
/* MODGET: Read module record                                        */         
/*********************************************************************/         
                                                                                
modget:                                                                         
                                                                                
parse arg $modgetno, $modgetdsc, $modgetfid                                     
                                                                                
signal off error                                                                
"EXECIO 1 DISKR" $modgetfid $modgetno+v.sys_io "(VAR $MODREC"                   
signal on error                                                                 
$modgetrc = rc                                                                  
modopenr = 1                                                                    
                                                                                
if $modgetrc ^= 0 then do                                                       
   call logsumm "0124A EXECIO DISKR ("right($modgetrc,5)")",                    
   $modgetdsc "rcd ("right($modgetno+v.sys_io,5)")",                            
   "'"$modgetfid"'"                                                             
   return 0                                                                     
   end                                                                          
                                                                                
return 1                                                                        
                                                                                
                                                                                
/*********************************************************************/         
/* MODPUT: Write new module records if appropriate                   */         
/*********************************************************************/         
                                                                                
modput:                                                                         
                                                                                
if ^op_nogen then do                                                            
   "EXECIO 1 DISKW" modfn modft modfm "(VAR $MODREC"                            
   modopenw = 1                                                                 
   end                                                                          
                                                                                
newmodrc = newmodrc + 1                                                         
return                                                                          
                                                                                
/*********************************************************************/         
/* EDPLUS: Affix (+) to positive number                              */         
/*********************************************************************/         
                                                                                
edplus:   procedure                                                             
arg n                                                                           
if n > 0 then return right("+"n,3)                                              
else return right(n,3)                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* TXTLOC: Check that address reference valid                        */         
/*********************************************************************/         
                                                                                
txtloc:   procedure expose cpfx mpfx xfn,                                       
        esdidx. esdtyp. esdid. esdorg. esdlen.                                  
                                                                                
arg $desc, $id, $esdid, $addr, $len                                             
                                                                                
parse value secloc($desc,$id,$esdid) with ok $esdptr                            
if ^ok then return 0                                                            
                                                                                
$off = $addr - esdorg.$id.$esdptr                                               
                                                                                
if $off < 0 then do                                                             
   say mpfx"0038E" $desc "address ("$addr") < ESD address",                     
   "("esdorg.$id.$esdptr")"                                                     
   return 0                                                                     
   end                                                                          
                                                                                
if $off+$len > esdlen.$id.$esdptr then do                                       
   say mpfx"0039E" $desc "length/offset ("$len"/"$off")",                       
   "exceeds ESD length ("esdlen.$id.$esdptr")"                                  
   return 0                                                                     
   end                                                                          
                                                                                
return 1 $off+1 $esdptr                                                         
                                                                                
                                                                                
/*********************************************************************/         
/* CLSTHDRS: Build Configuration Listing headings                    */         
/*********************************************************************/         
                                                                                
clsthdrs:                                                                       
                                                                                
arg $repid                                                                      
                                                                                
h.$repid.0 = 3                                                                  
hlin.$repid = 5                                                                 
                                                                                
h.$repid.1 = "0" ||,                                                            
      center("--- CONFIGURATION LISTING ---",linwid)                            
                                                                                
h.$repid.2 = "0" ||,                                                            
      center(,                                                                  
      center("SEQ",3),                                                          
      center("STATEMENT",cfgprtlr),,                                            
      linwid)                                                                   
                                                                                
h.$repid.3 = " " ||,                                                            
      center(,                                                                  
      center("",3,"-"),                                                         
      center("",cfgprtlr,"-"),,                                                 
      linwid)                                                                   
                                                                                
newsec.$repid = 1                                                               
endrep.$repid = 1                                                               
return                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* XSUMHDRS: Build Execution Summary headings                        */         
/*********************************************************************/         
                                                                                
xsumhdrs:                                                                       
                                                                                
arg $repid                                                                      
                                                                                
h.$repid.0 = 3                                                                  
hlin.$repid = 5                                                                 
                                                                                
h.$repid.1 = "0" ||,                                                            
      center("--- MODULE SUMMARY ---",linwid)                                   
                                                                                
h.$repid.2 = "0" ||,                                                            
      center(,                                                                  
      center("SEQ",5),                                                          
      center("OWNER-ID",8),                                                     
      center("DISK",4),                                                         
      center("FILE-ID",20),                                                     
      center("UPDATED",13),                                                     
      center("XR",2),                                                           
      center("A C T I O N",73),,                                                
      linwid)                                                                   
                                                                                
h.$repid.3 = " " ||,                                                            
      center(,                                                                  
      center("",5,"-"),                                                         
      center("",8,"-"),                                                         
      center("",4,"-"),                                                         
      center("",20,"-"),                                                        
      center("",13,"-"),                                                        
      center("",2,"-"),                                                         
      center("",73,"-"),,                                                       
      linwid)                                                                   
                                                                                
newsec.$repid = 1                                                               
endrep.$repid = 1                                                               
return                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/* MODHDRS: Build MODULE info headers                                */         
/*********************************************************************/         
                                                                                
modhdrs:                                                                        
                                                                                
arg $modhdrset, $modhdridx, $modhdrep1                                          
                                                                                
if modxa then $modhdrgen = "XA"                                                 
else $modhdrgen = "370"                                                         
if modrld then $modhdrgen = $modhdrgen"/R"                                      
                                                                                
h.$modhdrset.$modhdridx = "0" ||,                                               
  center(,                                                                      
  left("TARGET",12,hsc)  || right(modfn modft modfm,20,hsc),                    
  hsp,                                                                          
  left("ADDRESS",12,hsc) || right(d2x(modfrdec)"-"d2x(modtodec),20,hsc),        
  hsp,                                                                          
  left("LENGTH",12,hsc)  || right(d2x(modlen) "("modkbs"K)",20,hsc),,           
  linwid)                                                                       
                                                                                
$modhdridx = $modhdridx + 1                                                     
                                                                                
h.$modhdrset.$modhdridx = " " ||,                                               
  center(,                                                                      
  left("GENTYPE",12,hsc)     || right($modhdrgen,20,hsc),                       
  hsp,                                                                          
  left("",12)                || right("",20),                                   
  hsp,                                                                          
  left("FMT/LRL/RCD",12,hsc) || right(modrf"/"modlr"/"oldmodrc,20,hsc),,        
  linwid)                                                                       
                                                                                
$modhdridx = $modhdridx + 1                                                     
                                                                                
h.$modhdrset.$modhdridx = " " ||,                                               
  center(,                                                                      
  left("LOCATED",12,hsc)    || right(dskusr.dskidx dskdev.dskidx,20,hsc),       
  hsp,                                                                          
  left("",12)                || right("",20),                                   
  hsp,                                                                          
  left("CREATED",12,hsc)     || right(modda modti,20,hsc),,                     
  linwid)                                                                       
                                                                                
return 3 4                                                                      
                                                                                
                                                                                
/*********************************************************************/         
/* LOGSUMM: Log summary info                                         */         
/*********************************************************************/         
                                                                                
logsumm:                                                                        
                                                                                
parse arg $logsumm_msg                                                          
$logsumm_msg = strip($logsumm_msg,'t')                                          
                                                                                
call prt 2, eddsk(2) edfid(2) edmsg($logsumm_msg)                               
                                                                                
if op_histo then do                                                             
                                                                                
   $hstrec = left(cfgfn,8),                                                     
             statdat,                                                           
             substr(stattim,1,4),                                               
             dskusr.dskidx dskdev.dskidx,                                       
             left(modfn,8) left(modft,8) modfm modda modti,                     
             substr("-NX",modxa+2,1)substr("-NR",modrld+2,1),                   
             left($logsumm_msg,59) || right(x2c(dskdev.dskidx),2,"0"x)          
                                                                                
   "EXECIO 1 DISKW" hstfid "0 F" length($hstrec) "(VAR $HSTREC"                 
   hstrc = hstrc + 1                                                            
   end                                                                          
                                                                                
return                                                                          
                                                                                
                                                                                
/* DSKLOG routine ---------------------------------------------------*/         
                                                                                
dsklog:                                                                         
                                                                                
parse arg $dskmsg                                                               
$dskmsg = strip($dskmsg,'t')                                                    
                                                                                
if op_trace then say mpfx"0045I" dskusr.dskidx dskdev.dskidx $dskmsg            
                                                                                
call prt 2, eddsk(2) right("",37,"*") edmsg($dskmsg)                            
                                                                                
if op_histo then do                                                             
                                                                                
   $hstrec = left(cfgfn,8),                                                     
             statdat,                                                           
             substr(stattim,1,4),                                               
             dskusr.dskidx dskdev.dskidx,                                       
             left("",8) left("",8) left("",2) left("",6) left("",6),            
             left("",2),                                                        
             left($dskmsg,59) || right(x2c(dskdev.dskidx),2,"0"x)               
                                                                                
   "EXECIO 1 DISKW" hstfid "0 F" length($hstrec) "(VAR $HSTREC"                 
   hstrc = hstrc + 1                                                            
   end                                                                          
                                                                                
return                                                                          
                                                                                
                                                                                
/**********************************************************************/        
/* VBCK: Validate backup directory                                    */        
/*                                                                    */        
/* (Format:)                                                          */        
/*                                                                    */        
/* 1  2  3  4   5  6   7   8   9    10   11  12  13  14  15  16       */        
/* GN D1 T1 OWN DV MFN MFT MNO MUPD MUPT MLR MBL MBZ BFN BFT RS       */        
/**********************************************************************/        
                                                                                
vbck:                                                                           
                                                                                
signal off error                                                                
"L" bckfid "(LIFO NOH DA"                                                       
signal on error                                                                 
listrc = rc                                                                     
                                                                                
if listrc = 0 then do                                                           
   pull . . . bckrf bcklr .                                                     
   "EXECIO * DISKR" bckfid "(FINIS STEM BCK."                                   
                                                                                
   do i=1 to bck.0                                                              
                                                                                
      if words(bck.i) < 16 then do                                              
         say mpfx"0050E B/O directory ("bckfid","i") words missing"             
         return 0                                                               
         end                                                                    
                                                                                
      bomgn = word(bck.i,1)                                                     
      bomfn = word(bck.i,14)                                                    
      bomft = word(bck.i,15)                                                    
      bomftseq = substr(bomft,2)                                                
      bomfid = bomfn bomft v.bckfm                                              
                                                                                
      if length(bomgn) ^= 1 | verify(bomgn,"01") > 0 then do                    
         say mpfx"0057E B/O directory ("bckfid","i") gen indr invalid",         
         "("bomgn")"                                                            
         return 0                                                               
         end                                                                    
                                                                                
      if length(bomft) ^= 8 | substr(bomft,1,1) ^= "+" |,                       
         verify(bomftseq,numchr) > 0 then do                                    
         say mpfx"0051E B/O directory ("bckfid","i") filetype invalid",         
         "("bomft")"                                                            
         return 0                                                               
         end                                                                    
                                                                                
      bckseq = bomftseq/1                                                       
                                                                                
      if i > 1 then select                                                      
         when bckseq <= bcklst then do                                          
            say mpfx"0052E B/O directory ("bckfid","i") index seq err:",        
            "last("bcklst") curr("bckseq")"                                     
            return 0                                                            
            end                                                                 
         when (bckseq-bcklst) > 1 then do                                       
            say mpfx"0053I B/O directory ("bckfid","i") index gap:",            
            "last("bcklst") curr("bckseq")"                                     
            end                                                                 
         otherwise                                                              
         end                                                                    
      bcklst = bckseq                                                           
                                                                                
      if bomgn then do                                                          
         signal off error                                                       
         "ESTATE" bomfid                                                        
         signal on error                                                        
         statrc = rc                                                            
         if statrc ^= 0 then do                                                 
            say mpfx"0054E B/O directory ("bckfid","i") no mod",                
            "("bomfid") ("statrc")"                                             
            return 0                                                            
            end                                                                 
         end                                                                    
      end                                                                       
                                                                                
   bckseq  = bckseq + 1                                                         
   if v.bckbgn > bckseq then bckseq = v.bckbgn                                  
   end                                                                          
                                                                                
else bckseq = v.bckbgn                                                          
drop bck.                                                                       
                                                                                
                                                                                
/**********************************************************************/        
/* Now check that no files exist on b/o disk with sequenced filetype  */        
/* .ge. starting sequence number implied by parm or existing b/o dir: */        
/**********************************************************************/        
                                                                                
q1 = queued()                                                                   
signal off error                                                                
"L" v.bckfn "+%%%%%%%" v.bckfm "(DA LIFO NOH"                                   
signal on error                                                                 
files = queued() - q1                                                           
ok = 1                                                                          
                                                                                
do i=1 to files                                                                 
   pull bomfn bomft bomfm .                                                     
   bomfid = bomfn bomft bomfm                                                   
   bomftseq = substr(bomft,2)                                                   
   if verify(bomftseq,numchr) > 0 then iterate i                                
   if bomftseq >= bckseq then do                                                
      say mpfx"0055E B/O fileid ("bomfid") >= starting seqno",                  
      "("bckseq")"                                                              
      ok = 0                                                                    
      end                                                                       
   end                                                                          
                                                                                
return ok                                                                       
                                                                                
                                                                                
/* VDSK routine ------------------------------------------------------*/        
                                                                                
vdsk:   procedure expose mpfx cpfx xfn,                                         
        numchr hexchr dskfid dsklr dskrc,                                       
        dskusr. dskdev. dskatt. dskattseq. dsktodbgn. dsktodlas.,               
        dsklnkmod. dsklnkrc. dskaccrc. dskacctyp. dskelim.                      
                                                                                
signal off error                                                                
"L" dskfid "(LIFO NOH DA"                                                       
signal on error                                                                 
lstrc = rc                                                                      
                                                                                
if lstrc /= 0 then do                                                           
   say mpfx"0062E DSK file '"dskfid"' not found"                                
   return 0                                                                     
   end                                                                          
                                                                                
pull . . . dskrf dsklr dskrc .                                                  
                                                                                
if dskrf /= "F" then do                                                         
   say mpfx"0063E DSK file '"dskfid"' not RECFM F"                              
   return 0                                                                     
   end                                                                          
                                                                                
"EXECIO * DISKR" dskfid "(FINIS STEM DSKREC."                                   
                                                                                
mustsort = 0                                                                    
                                                                                
do i=1 to dskrc                                                                 
   parse upper var dskrec.i dskusr dskdev dskatt dskattseq .                    
                                                                                
   if dskdev = "" then do                                                       
         say mpfx"0064E DSK ("i") USER/DEV missing"                             
         return 0                                                               
         end                                                                    
                                                                                
   if dskatt    = "" then dskatt    = 1                                         
   if dskattseq = "" then dskattseq = 0                                         
                                                                                
   if length(dskdev) > 4 | verify(dskdev,hexchr) > 0 then do                    
      say mpfx"0065E DSK ("i") DEV invalid"                                     
      return 0                                                                  
      end                                                                       
                                                                                
   if length(dskatt) ^= 1 | verify(dskatt,"01") > 0 then do                     
      say mpfx"0066E DSK ("i") ATTEMPT INDR invalid"                            
      return 0                                                                  
      end                                                                       
                                                                                
   if length(dskattseq) > 4 | verify(dskattseq,numchr) > 0 then do              
      say mpfx"0067E DSK ("i") ATTEMPT SEQ invalid"                             
      return 0                                                                  
      end                                                                       
                                                                                
   dskkey.i = left(dskusr,8) || right(x2c(dskdev),2,"0"x)                       
                                                                                
   if i > 1 then do                                                             
      lastdsk = i-1                                                             
      if dskkey.lastdsk > dskkey.i then mustsort = 1                            
      end                                                                       
   end                                                                          
                                                                                
if mustsort then do                                                             
   do i=1 to dskrc                                                              
      dskkey.i = dskkey.i || right(i,5,0)                                       
      end                                                                       
                                                                                
   "RXGRADE DSKKEY. GRADE."                                                     
                                                                                
   do i=1 to dskrc                                                              
      dskkey.i = substr(dskkey.i,1,10)                                          
      end                                                                       
   end                                                                          
                                                                                
do i=1 to dskrc                                                                 
                                                                                
   if mustsort then next = grade.i                                              
   else next = i                                                                
                                                                                
   dskusr.i = substr(dskkey.next,1,8)                                           
   dskdev.i = c2x(substr(dskkey.next,9,2))                                      
                                                                                
   if i > 1 then do                                                             
      if laskey = dskkey.next then do                                           
         say mpfx"0068E DSK ("next") duplicate:" dskusr.i dskdev.i              
         return 0                                                               
         end                                                                    
      end                                                                       
                                                                                
   dskatt.i    = word(dskrec.next,3)                                            
   dskattseq.i = word(dskrec.next,4)                                            
   dsktodbgn.i = word(dskrec.next,5)                                            
   dsktodlas.i = word(dskrec.next,6)                                            
   dsklnkmod.i = word(dskrec.next,7)                                            
   dsklnkrc.i  = word(dskrec.next,8)                                            
   dskaccrc.i  = word(dskrec.next,9)                                            
   dskacctyp.i = word(dskrec.next,10)                                           
   dskelim.i   = word(dskrec.next,11)                                           
                                                                                
   if dskatt.i    = "" then dskatt.i    = 1                                     
   if dskattseq.i = "" then dskattseq.i = 0                                     
                                                                                
   laskey      = dskkey.next                                                    
   end                                                                          
                                                                                
do i=1 to dskrc                                                                 
   if ^dskupd(i,"") then return 0                                               
   end                                                                          
                                                                                
"FINIS" dskfid                                                                  
                                                                                
return 1                                                                        
                                                                                
                                                                                
/* DSKUPD routine ----------------------------------------------------*/        
                                                                                
dskupd: procedure expose mpfx cpfx xfn,                                         
        dskfid dsklr,                                                           
        dskusr. dskdev. dskatt. dskattseq. dsktodbgn. dsktodlas.,               
        dsklnkmod. dsklnkrc. dskaccrc. dskacctyp. dskelim.                      
                                                                                
arg pos,finis                                                                   
                                                                                
orec = dskusr.pos dskdev.pos left(dskatt.pos,1,1),                              
       right(dskattseq.pos,4,0),                                                
       left(dsktodbgn.pos,12,"*") left(dsktodlas.pos,12,"*"),                   
       left(dsklnkmod.pos,2,"*") right(dsklnkrc.pos,4,"*"),                     
       right(dskaccrc.pos,4,"*") left(dskacctyp.pos,4,"*"),                     
       left(dskelim.pos,1,"*")                                                  
                                                                                
orecl = length(orec)                                                            
                                                                                
if orecl > dsklr then do                                                        
   say mpfx"0069E DSK file lrecl ("dsklr") < min required ("orecl")"            
   return 0                                                                     
   end                                                                          
                                                                                
"EXECIO 1 DISKW" dskfid pos "(VAR OREC" finis                                   
return 1                                                                        
                                                                                
                                                                                
/* VLNKMOD routine ---------------------------------------------------*/        
                                                                                
vlnkmod: procedure expose mpfx cpfx xfn                                         
                                                                                
arg mode                                                                        
                                                                                
mode = strip(mode,'b')                                                          
lmode = length(mode)                                                            
                                                                                
if lmode < 1 | lmode > 2 | find("R RR W WR M MR",mode) = 0 then do              
   say mpfx"0070E LNKMOD missing or invalid"                                    
   return 0                                                                     
   end                                                                          
                                                                                
return 1                                                                        
                                                                                
                                                                                
/* RELDISK routine ---------------------------------------------------*/        
                                                                                
reldisk: procedure expose mpfx cpfx xfn                                         
                                                                                
arg dev                                                                         
                                                                                
"RELEASE" dev                                                                   
return                                                                          
                                                                                
                                                                                
/* DETDISK routine ---------------------------------------------------*/        
                                                                                
detdisk: procedure expose mpfx cpfx xfn                                         
                                                                                
arg dev                                                                         
                                                                                
detrsp= diagrc(8,"DETACH" dev)                                                  
detrc = substr(detrsp,1,9)                                                      
                                                                                
if detrc ^= 0 then do                                                           
   say mpfx"0071E" substr(detrsp,17)                                            
   signal error                                                                 
   end                                                                          
                                                                                
return                                                                          
                                                                                
                                                                                
/*********************************************************************/         
/*  Syntax Error Exit                                                */         
/*********************************************************************/         
                                                                                
syntax:                                                                         
ec = rc                                                                         
"SET CMSTYPE RT"                                                                
work="REXX Error ("ec"), line ("sigl"), EXEC ("xfn"):"                          
say cpfx"SYS9990E "work                                                         
say cpfx"SYS9990E "errortext(ec)                                                
say cpfx"SYS9990E "strip(sourceline(sigl))                                      
exit 990                                                                        
                                                                                
/*********************************************************************/         
/*  Non-0 Host Command Return Code Exit                              */         
/*********************************************************************/         
                                                                                
error:                                                                          
ec = rc                                                                         
"SET CMSTYPE RT"                                                                
work="Unexpected return code ("ec"), line ("sigl"), EXEC ("xfn"):"              
say cpfx"SYS9991E "work                                                         
say cpfx"SYS9991E "strip(sourceline(sigl))                                      
exit 991                                                                        
                                                                                
                                                                                
/*********************************************************************/         
/*  Unassigned variable reference exit                               */         
/*********************************************************************/         
                                                                                
novalue:                                                                        
"SET CMSTYPE RT"                                                                
work="Unassigned variable, line ("sigl"), EXEC ("xfn"):"                        
say cpfx"SYS9992E "work                                                         
say cpfx"SYS9992E "strip(sourceline(sigl))                                      
exit 992                                                                        
